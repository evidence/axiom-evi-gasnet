Update strategy
===============
RDMA support for LAPI conduit is currently implemented with #ifdef
regions providing the required functionality.  Jason has added
the --enable-lapi-rdma configure option that adds GASNETC_LAPI_RDMA
to the compilation environment.

Setup (mostly in gasnet_core.c:gasnetc_attach())
================================================

In this routine we take the regular segment (SEGMENT_FAST only)
and split it up into a number of 32MB regions, each with its
own PVO (LAPI_Util with LAPI_XLATE_ADDRESS).  These PVOs are
then exchanged (loop of LAPI_Address_init64() calls).  In addition
lapi_remote_ctxt_t objects are obtained (LAPI_Util with
LAPI_RDMA_ACQUIRE).  At this point a node has enough to identify
and manipulate data in the shared segment on any other node.

Finally, target notification callbacks are registed for ensuring
GASNet semantics for completion of PUT operations (see subsequent
discussion)

GET Operations
==============

Shared segment to shared segment
--------------------------------

The only issue here is decomposing the transfer so that each RDMA
operation does not cross PVO boundaries.  The strategy taken here
is to loop over source regions, splitting the transfer into one
or two, depending on whether the source region crosses a PVO boundary
at the target.

[Alternative: Investigate interchanging loop order]

Out of shared segment to shared segment
---------------------------------------

Bounce buffers are used for transfers shorter than 
gasnete_pin_threshold.  For longer transfers,
the regions are lined up, i.e. the source PVO boundaries are matched
to target PVO boundaries.  The source regions are then pinned using 
this decomposition and the LAPI_Xfer() calls are made.

Completion
----------

Here the origin counter is sufficient.  Upon completion all the source
out of segment registrations are freed.

[Improvements (probably mandatory for any kind of performance):
Use firehose to manage source pinning etc.]

PUT Operations
==============

The decomposition strategy is similar to GETs.  The only wrinkle here
is that the origin counter only indicates local completion.
For remote completion we use the following strategy:

At setup each node decides on a number of tags, the number of
concurrent transfers it would like to handle.  Each node also
registers a remote callback for each tag (a single function pointer,
with a different sinfo for each tag).  Each tag is associated with a
word at the initiator.  For PUT operations the initiator gets a free
word from an array indexed by tag.  This location in the array is
atomically set to OCCUPIED.  This tag is then placed in the rdma_tag
field of the HwXfer struct.  In addition the completion pointer is
placed at the corresponding part in an array of completion pointers.
When the remote node receives the data of the put, the
callback is executed with (source, tag) as arguments.  
This lets it call an AM at the source with the tag.  The AM just
increments the completion pointer and sets the tag location back to EMPTY.

[Alternative: In addition to the array of tags, pre-allocate an 
array of completion pointers.]

the target.  The initiator can pull this table periodically (some
intelligence is needed here).  This has the advantage of aggregating
not just the chunks of a single transfer, but multiple transfers as
well.  More investigation definitely needed]

[Alternative: Use LAPI_Fence() to ensure completion.  However, this 
completes
everything from the node which is probably too big of a hammer when we 
have
Pthreads.  We could get separate LAPI handles for each Pthread to 
solve this,
though.]

[Alternative: Have the notification handler update a table local to
the target.  The initiator can pull this table periodically (some
intelligence is needed here).  This has the advantage of aggregating
not just the chunks of a single transfer, but multiple transfers as
well.  More investigation definitely needed]


Managing GASNet Handles
=======================

For GETs, as mentioned earlier, only the origin counter and
list of locally pinned regions are needed.
For PUTs, the origin counter only helps us with source completion.
For target completion we also need to know when all the initiator's
words have been modified by the target.  We either need to keep the
list of words or have another counter be atomically updated when
the words are "reaped".
It's probably easiest to add a target counter and pointer to list of
PVOs to the eops/iops.  The list of PVOs will soon go.


Managing Network Buffers
========================

For short transfers we use pre-pinned network buffers.  They are of
size gasnete_pin_threshold and we have gasnete_num_nb of them.
They are managed with two lists, protected by a Pthread mutex (we can
do better synchronization in the future, if needed).  They are:
gasnete_free_nb_list, the free list, and gasnete_active_nb_list, 
the list of active operations.  Initiators get an entry from the
free list, if possible, and use the buffer for the transfer.  The
entry then gets put on the active list.  Upon completion of a
transfer, the entry is placed back on the free list.  If the
free list is empty, the initiator attempts to steal an unsynced
entry from the active list (pointers to origin counters are
also provided for the check).  

Tuning parameters
=================

GASNET_LAPI_RCTXTS_PER_NODE - a (small) integer specifying how many
remote contexts to open up to each peer.  Default value: 1

TODO List Once We Have a Machine
================================

- Get timings for pin/unpin
- Perform some empirical studies to help us choose
  among design alternatives, particularly for PUTs
- Local firehose (improved FAST & LARGE)
- Remote firehose (EVERYTHING)
- Revisit current AM implementation
- Check that resources get reaped as soon as possible
- Tests with threads
- Add GASNET_NETWORK_DEPTH environment variable
  Two issues: table size for puts
              number of network buffers
- Also have MAX_PVO be an environment variable
- The pin threshold
