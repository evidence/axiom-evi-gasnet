This is an implementation of the GASNET CORE and EXTENDED
API using the IBM LAPI communication protocol.

For more information about LAPI, see:

"Scientific Applications in RS/6000 SP Environments" 
section 3.5.  This is an IBM RedBook written by
Marcelo Barrios and a cast of thousands.  
ISBN: 0738415189
IBM Form Number: SG24-5611-00

===========================================================
NOTE: By default, the LAPI conduit runs in INTERRUPT mode.
In this mode, a seperate "notification" thread is created 
by the LAPI subsystem.  As messages arrive on the switch,
this thread is unblocked and runs the LAPI progress
engine.  
Lower latency for synchronous applications can be achieved
by placing LAPI into POLLING mode.  To do so, set the
following environment variable:

GASNET_LAPI_MODE=POLLING

before running the job.

===============================================================
The GASNET EXTENDED API is implemented directly over LAPI
PUT, GET and Amsend calls.  It does not use the GASNET CORE
AM calls.  It is advised that clients use the extended API
whenever possible.

===========================================================
Some Implementation details:

The implementation of the GASNET CORE, uses LAPI_Amsend()
active messages to implement the GASNET active messages.

In a LAPI active message call, the user specifies the
address of a (header) handler to run on the remote node,
an argument (uhdr), of limited size, which will be passed to the
handler, and an optional data payload.

LAPI active message handlers on the target task are
written in two pieces: a "header handler" and an
(optional) "completion handler".  The header handler
is executed by the LAPI dispatcher (progress engine)
when the first packet of the message arrives.  
When it executes, it is provided with a copy of the
uhdr and the size of the data payload specified in
the Amsend call.  The data payload, if specified,
is not available at the point of this call.

The header handler executes while holding a LAPI lock
and thus cannot block (indefinately) or issue
communication calls.  If the user send a data payload,
the header handler must inform the LAPI dispatcher where
to place the data as it arrives.  It does this through
its (void*) return agument.  For example, it might
malloc space for the data or return the address of a
know buffer location.  If the handler needs to perform
a blocking operation or communication, it must
arrange for a "completion handler" to be run at a
later time.  It does this by returning the address
of this function in the (void** comp_h) argument.
It can also specify an argument to this completion 
handler in the (void** uinfo) argument.

If the header handler specifies a completion handler, it
will be run in a seperate "completion" thread created
by the LAPI subsystem.  This handler will not run until
all the data spcified in the payload has arrived on the
target node.  The completion handler can execute 
arbitrary code, including blocking calls and LAPI 
communication calls.  

Several Notes:

(1) The LAPI dispatcher maintains a queue of ready
    completion requests.  The completion thread removes
    these requests and executes the given completion 
    handlers with the arguments provided by the
    header handler.  If there are no completion
    requests to execute, the completion thread sleeps
    on a condition variable.  The next time the dispatcher
    issues a request, it signals the condition variable to
    wake the completion thread.  The scheduling of a 
    completion handler can add 40-60 usec of latency to
    a LAPI active message.
(2) The (uhdr) arguemnt passed to the header handler
    cannot be arbirtairly large.  Its size is constrained
    by the size of a network packet minus the size of
    a LAPI implementation dependent header.  On the other
    hand, it is around 800 bytes in length so if the 
    payload is small enough, it can be packed into the
    uhdr.  Doing so, for smaller messages may eliminate
    the need for scheduling a completion handler and
    thus reduce message latency.
(3) The uhdr argument provided to the header handler
    is not available to the completion handler.  Any
    data that must be passed to the completion handler
    (through the uinfo argument) must be copied to
    memory space under the control of the application
    or GASNET layer.
(4) GASNET AM REQUEST calls will, in general, issue
    a REPLY and thus cannot be executed from within
    the LAPI header handler.  

The implementation of GASNET AM REQUESTS is as follows:
* gasnet tokens are implemented as follows:

typedef struct {
    gasnetc_flag_t       flags;
    gasnet_handler_t     handlerId;
    gasnet_node_t        sourceId;
    uintptr_t            destLoc;
    size_t               dataLen;
    uintptr_t            uhdrLoc;    /* only used on AsyncLong messages */
    gasnet_handlerarg_t  args[GASNETC_AM_MAX_ARGS];
} gasnetc_msg_t;

typedef struct gasnetc_token_rec {
    struct gasnetc_token_rec  *next;
    union {
	char             pad[GASNETC_UHDR_SIZE];
	gasnetc_msg_t    msg;
    } buf;
} gasnetc_token_t;

  That is, there is space for various fields, such as the
  handler index, flags, the source node ID and the handler
  arguments.  The remaining space (via the union pad field)
  is available for packed payload data.

* All uhdr arguments are gasnet tokens.
* For Medium and Large requests, if the data payload
  will fit in the remaining uhdr space, then
  it is copied there and a flag is set to inform the
  remote header handler the payload is packed.
  The data payload argument to LAPI_Amsend is set to NULL.

* On the remote task, when the header handler executes,
  if the message is SHORT, of if all the payload data
  was packed into the uhdr, the client REQUEST handler
  is ready to execute.  That is, no additional payload
  data will arrive.  Client request handlers cannot 
  execute in the header handler so it must either
  be done in the completion handler or a client thread.
  A new token is allocated, the uhdr data is copied
  to this token and it is placed on a "ready" request
  queue.
  If the request is a medium or long message and the
  payload data is not packed in the uhdr, a completion
  handler is scheduled and the lapi dispatcher is
  informed where to place the incoming payload data.
  For medium messages, the space is allocated via malloc.
  For large messages, the space is within the remote access
  region and the location was specified by the remote
  sender via the destLoc field in the token.  A new token
  is allocated, the input token is copied to it.  The new
  token is returned in the uinfo field which will appear
  as the argument of the completion handler, when it executes.

* Note that gasnet tokens, once allocated, are maintained
  on a local free list for quick allocation in the future.

* The tokens placed on the ready request queue are processed
  either in the completion handler, or from within GASNET_AMPOLL
  (by a client thread), whichever happens first.  In either case,
  the token is removed from the queue and the specified GASNET
  REQUEST handler is executed.  The token is then placed back
  on the free list.

* When client REQUEST handlers are executed, they have access 
  to the token.
  They pass this token to the REPLY active message.  The 
  REPLY code re-used this token as a uhdr argument when it 
  calls LAPI_Amsend() to implement the reply communication.

GASNET REPLYs are implemented as follows:

* Similar to the request calls, except that short, 
  and medium and long replys that have the payload
  packed into the uhdr can be executed directly from
  within the LAPI header handler.  This is because
  GASNET replies are restricted not to block or make
  communication calls.

* Replies with data payloads that are not packed into
  the uhdr schedule a completion handler as above.



