GASNet's Git Workflow
---------------------

The purpose of this document is to describe how git is to be used for GASNet
development, providing examples of the most common tasks.  This assumes you
have a basic working knowledge of git and is not a full tutorial.  This is a
companion to, but distinct from, the coding standards (in README) and
development rules in README-devel.

See also:
 + README: includes GASNet's coding standards
 + README-devel: rules developers are expected to follow when committing
 + README-release: detailed release procedure


A note on proprietary (NDA) information
---------------------------------------

A stern reminder that a "git clone" includes the entire history of everything
that has ever existed in the public repo, and that this public repo is world
readable.  So, you must NEVER "git push" anything to the public server (even to
a private branch that might be merged) that you don't have the rights to
publish.  A detailed "protocol" for dealing with proprietary data (especially
that with an expiration date) will eventually be added to this document.


Requirements
------------

This documentation was written using git-1.8 and git-flow.  Where known,
alternatives required for git-1.7 are included, but no effort has been expended
to back-port to older git releases.  If future versions of git break these
instructions, we'll update this document appropriately.

Since GASNet is hosted on BitBucket.org you will require an account there if
you are going to push (upload) anything to the repository.  Contact us at
upc-devel@lbl.gov to request Write permission for your BitBucket userid.

Example commands in this document will be written like
    $ git ...
consistent with the '$ ' prompt of a bash or other Bourne shell.  The examples
should work with ANY standard (Bourne or csh family) command shell.


Overview of git-flow
--------------------

The GASNet project is following the git-flow model.
(See http://nvie.com/posts/a-successful-git-branching-model/)
The basic ideas:

 + A long-lived 'master' branch holds public releases, and should generally
   have a tag for each commit.  If something is not worthy of a tag, then it
   probably doesn't belong in 'master').
   This is the default branch for most *users* to find stable versions.

 + A long-lived 'develop' branch is used for continuous integration.
   This is the branch *developers* should be working with.

 + Transient "feature branches" (off of 'develop') are used for work on each
   task, and are merged to 'develop' (and then deleted) only when the work is
   completed/tested.  These branches may be published to a public server, but
   often will exist only in the developer's local repository.

 + Transient "release branches" (also off of 'develop') are used to move work
   from the 'develop' branch to 'master'.  Ideally the only commits to a
   release branch will be version number changes and related updates to
   documentation.  However this is also the place to fix "issues" found while
   testing the release.  When release preparation is complete, release branches
   are merged to BOTH develop and master (and then deleted).

 + Transient "hotfix branches" are for fixing urgent issues in the code on
   'master'.  They work just like release branches except that they branch from
   'master' instead of from 'develop'.

 + All branch merges are done following a rebase (to keep linear history) but
   with --no-ff to force a "true merge" which preserves a clear start and end
   to the commits from each feature branch.

The name "git-flow" refers to both the work-flow we have adopted AND to a set
of extensions to git which provide automation of many of the steps required to
follow the work-flow.  Use of the git-flow extensions is entirely optional.
However, you will see in the remainder of this document there is much less to
remember (and type) if you do use git-flow.  You can obtain git-flow from
github at
    https://github.com/nvie/gitflow/wiki

To enable use the git-flow extensions, GASNet is using the branch names
"master" and "develop" to match the git-flow defaults.  Similarly, the use of
"feature/", "release/" and "hotfix/" are strongly recommended when naming
branches of the corresponding types to match the git-flow defaults.
   
Git-flow is just a collection of wrappers around standard git operations, with
no hidden state or "magic".  So, as long as the naming conventions for branches
is applied consistently, one can freely move between git-flow and plain git
commands to work on your repository.  In particular, a branch which is created
with git-flow can safely be merged using plain git and vise versa.


Setup
-----

To clone the GASNet repo use either of the following:
    $ git clone https://USER@bitbucket.org/berkeleylab/gasnet
or
    $ git clone git@bitbucket.org:berkeleylab/gasnet.git
The first option (https) will require your password for every push, while the
second (ssh) requires that you upload an ssh public key to BitBucket.  See
    https://confluence.atlassian.com/display/BITBUCKET/Set+up+SSH+for+Git
for help with the key upload.  If you have a suitable key already, you can
probably skip right to step #6.

As a developer, the first thing you probably want to do is:
    $ git checkout develop
If your git is too old (prior to 1.7) for that command to work, try this:
    $ git checkout --track -b develop origin/develop
BUT be warned that none of our git usage instructions have been tested
with anything older than git-1.7.

If you will be using the git-flow extensions you need to initialize git-flow.
Since we use the defaults for branch names, this just takes two steps:
    $ git flow init -d
    $ git config gitflow.prefix.versiontag gasnet-
Where the second ensures release tags of the form "gasnet-1.2.3".  This step
only writes a few strings to .git/config, none of which impact use of the
standard git commands.  If you are uncertain if you want to use git-flow it is
fine to defer this initialization until the first time you use "git flow ...".

If you've not been using git on this host before, you probably want to start
with the following to configure your name and email before you push anything:
    $ git config --global user.name "Jane Doe"
    $ git config --global user.email "JDoe@lbl.gov"
You can omit "--global" if you want this identity for ONLY the current repo.


Tracking 'origin'
-----------------

Unless you have done something unusual, the 'develop' branch in your clone from
BitBucket should automatically be tracking 'origin/develop' (and 'master' will
track 'origin/master').  The most basic command for tracking updates is "git
pull", BUT there are some risks that are associate with pull, as described in
detail at https://coderwall.com/p/jiswdq

To summarize: "git pull" will perform a merge which can generate undesired
non-linear history while "git pull --rebase" will flatten the desirable merge
commits which result from merging feature (or release) branches.

The alternative that avoids the risks is a two-step process:
    $ git fetch
    $ git rebase -p [origin/develop develop]
Where the arguments "origin/develop develop" are optional for git-1.8, but are
required with git-1.7.

This works like "git pull --rebase", but with the important addition of the
'-p' ('--preserve-merges') option to the rebase step to preserve the desired
branch structure.

Of course, if your local 'develop' branch has no un-pushed commits, then both
"git pull" and "git pull --rebase" are perfectly safe.


General Development
-------------------

We want to start every development task on a *distinct* branch off of
'develop'.  These branches are called "feature branches", but are to be used
for bug fixes, documentation updates, and generally anything that is
"non-trivial".

When merging feature branches to develop, we want a (nearly) linear history,
but want to be able to clearly see the start and end of the sequence of commits
which correspond to any given feature branch.  So, we want a "true merge" with
a commit which is a summary of the branch (bug fix, enhancement, etc.) which is
being merged.  Therefore, we do NOT want a fast-forward but still require a
rebase prior to merging to keep a linear history.  This gets clearer in the
examples below.

If one is using git-flow then the sequence for a feature branch "example" is:
    [begin with an up-to-date 'develop']
    $ git flow feature start example
    [work on the branch until the task is done and tested]
    $ git flow feature finish -r example
    $ git push origin develop
The '-r' option to the finish forces a rebase to ensure a (nearly) linear
history if you have other commits/merges to 'develop' between the start and
finish of this feature branch.

If there is a merge conflict, resolve the conflict(s) and run "git commit" to
complete the merge.  After that, there are two choices: you can simply reissue
the "finish" which should pick up where it left off, OR you can complete the
remaining step (branch deletion) using the non-git-flow steps, below.

It is worth noting that if the feature branch contains exactly one commit, then
git-flow will perform a fast-forward commit.  This is under the assumption that
a single-commit branch is a "trivial" change, and is consistent with GASNet's
desired practice.  HOWEVER, if you want to have a true merge you can use the
non-git-flow steps below even if you used git-flow to create the branch.  If you
only want the opportunity to edit the commit message, that can always be done
using "git commit --amend" prior to the push.

To get the same behavior with plain git (without git-flow):
    [begin with an up-to-date 'develop']
    $ git checkout -b feature/example develop
    [work on the branch until the task is done and tested]
    $ git rebase develop feature/example
    $ git checkout develop
    $ git merge [--log] --edit --no-ff feature/example
    $ git branch -d feature/example
    $ git push origin develop

Some notes on the merge step:
  --log  Optionally seeds the commit message with the summary (first line) of
         each of the constituent commits. 
  --edit Required so one can edit the commit message to write a description of
         the work being merged.

The --edit flag to "git merge ..." doesn't exist in git-1.7, but it can be
simulated by using a two-step merge+commit:
    $ git merge [--log] --no-commit --no-ff feature/example
    $ git commit
which invokes the editor at the commit step.

So, what to do in case of a push failure above (race against a peer)?
If your post-merge "git push origin develop" fails with
  ! [rejected]        develop -> develop (non-fast-forward)
then you should fetch and then rebase onto an up-to-date 'origin/develop':
    $ git fetch
    $ git rebase -p [origin/develop develop]
    $ git push origin develop
Where the rebase arguments "origin/develop develop" are optional for git-1.8,
but are required with git-1.7.  As described earlier, the "-p" is vital to
preserving the branch structure we are trying to achieve, and is the reason
that we should not use the more common "git pull --rebase".

One caveat here is that if you were to delay removing the feature branch until
after the (failed) push, you must use "-D" instead of "-d"
    $ git branch -D feature/example
because the "rebase -p" results in git not realizing that your
branch has been fully merged.  So, this is motivation to keep the push last.

Note that the fetch+rebase-p approach will preserve the branch structure even
if you have merged multiple feature branches to your local 'develop' since the
last fetch or pull.  This is a good thing if you need to work disconnected for
an extended period.


Releases
--------

Even with Write access to the BitBucket repo, users don't have push rights to
'master' by default.  If you need to produce releases, ask one of the
repository Admins to grant you push access.

For a release branch the steps using git-flow are much the same as for
development.  For a hypothetical release of version 9.8.0:
    [begin with an up-to-date 'develop' and 'master']
    $ git flow release start 9.8.0
    [prepare the release following the procedure in README-devel]
    $ git flow release finish -m "GASNet release 9.8.0" 9.8.0
    $ git push --tags origin develop master

When using plain git commands there is just a minor difference because we don't
want to rebase onto 'develop' once the branch has started (because we
explicitly branched to keep concurrent changes on 'develop' from entering the
release).  We do still want a non-fast-forward commit.  The steps look like:
    [begin with an up-to-date 'develop' AND 'master']
    $ git checkout -b release/9.8.0 develop
    [prepare the release following the procedure in README-devel]
    $ git checkout master
    $ git merge --edit --no-ff release/9.8.0
    $ git tag -a ganet-9.8.0 -m "GASNet release 9.8.0" master
    $ git checkout develop
    $ git merge --edit --no-ff release/9.8.0
    $ git branch -d release/9.8.0
    $ git push --tags origin develop master
If using git-1.7 there is no support for "merge --edit"; see the text
regarding merging feature branches for the merge+commit alternative.

It may happen that while testing the release one finds that some feature on
'develop' is broken and must be excluded from the release.  In that case a "git
revert" of the feature will be part of "[prepare the release...]".  However,
this does not mean that the feature MUST be reverted on 'develop' as well.  If
you *do* want it reverted on 'develop' then no extra actions are required
(though you should consider how you will resume work on the feature).  If you
want to retain the feature on 'develop' then you must take care to exclude the
revert from what gets merged to 'develop'.  While this is possible to do with
git-flow (by amending the merge commit prior to pushing), it is probably easier
to handle this situation using plain git, by reversing to revert on the release
branch between "checkout develop" and the merge that follows it.


Aliases
-------

[TODO: develop easy to use short-cuts, or at least give examples of what can be
done?]


Proprietary (NDA) information
-----------------------------

[TODO: describe a detailed protocol]

At a VERY high-level:
+ Do NOT conduct NDA work using the BitBucket repository.
+ Work from a clone on a "controlled" machine.
+ Don't clone your repo containing NDA-covered to any "uncontrolled" machine.
+ Consider using "git archive" to move files w/o conveying any history or
  deleted files.
+ Consider using "git archive" to import the final code (but no history or
  deleted files) once it is allowable to do so.
