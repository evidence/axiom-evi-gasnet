README file for vapi-conduit
================================
Paul H. Hargrove <PHHargrove@lbl.gov>

@ TOC: @
@ Section: Core API @
@ Section: Extended API @
@ Section: Graceful exits @
@ Section: TO DO @


@ Section: Core API @

+ Flow-control for AMs.

  The AMs in vapi-conduit are just implemented as send/recv traffic.
  Therefore a send without a corresponding recv buffer preposted at the
  peer will be stalled by the RNR (receiver-not-ready) flow control
  in IB.  However there are two reasons why we want to avoid this
  situation.  The first is that if such a send is blocked by flow
  control, then the ordering semantics of IB tell us that all the
  gets and puts that we've initiated after the AM was sent are also
  stalled.  Rather than let that happen, we should manually delay
  those which are dependent on the AM.  The second reason is that
  under some conditions the RNR flow control is very poor.  The problem
  is that once the intended receiver sends a RNR NAK to indicate no
  available recv buffers, IB has the SENDER's hardware/firmware poll
  for the receiver to become ready again!  That leaves us with a choice
  between configuring a small polling interval and consuming a lot of
  bandwidth for this polling, or a large interval which leads to more
  performance which is degraded more than necessary when IB flow control
  is asserted.

  For these reasons we implement some flow control at the AM level.
  The basic idea is that every REQUEST consumes one credit on the
  sending endpoint and every REPLY grants one credit on the receiving
  endpoint.  Thus if M is the initial number of credits on each endpoint
  and every REQUEST has exactly one matching REPLY, then M becomes a
  limit on the number of un-acknowledged REQUESTS in flight on an
  endpoint.  If we want to avoid RNR conditions, then we should start
  with M credits and 2*M preposted recv buffers on each endpoint.  The
  factor of 2 is because we can consume M of the buffers on the peer's
  endpoint with out REQUESTs and an additional M for REPLYs to her
  REQUESTS.

  It is a simple matter to count the credits when a REPLY is received
  and to poll for credits when needed to send a REQUEST.  It is also
  simple to ensure the exactly-one-reply.  We already ensure that
  at-most-one reply is sent by the request handler.  Additionally we
  must check upon handler return for the case that the request hander
  sent no reply, and send one implicitly.  We just use a special
  "system category" handler, gasnetc_SYS_ack, which doesn't even run
  an handler.

  To avoid a window of time between when we send a reply (credit) and
  when we post the recv buffer, we must post the replacement recv
  buffer BEFORE running the AM REQUEST handler.  To do this we keep a
  pool of unposted recv buffers.  So, when we recv a REQUEST, we grab
  a free recv buffer from the pool and post it to the endpoint, run
  the handler, send an implicit reply if the handler didn't send any
  and finally we take the recv buffer containing the REQUEST and we
  return it to the unposted pool.  When get recv a REPLY we don't
  bother with as much complication, and just repost the recv holding
  the REQUEST, after running the handler.

  If we reap multiple REQUESTS in a single Poll, then we reuse the
  previous buffer as the "spare" for the next one, in place of
  grabbing one from the unposted pool each time.  Thus, we touch the
  lock on the unposted pool at most twice per Poll, once for the
  first REQUEST we recieve and once at the end to put the recv buffer
  of the final REQUEST back in the unposted pool.  For the dedicated
  receive thread we do even better, never touching the unposted pool
  at all by keeping a single thread-local "spare" at all times.

@ Section: Extended API @

Notes for myself for extended API:

+ The send completion facility consists of two pointers to counters,
  associated with each sbuf.  If these pointers are non-NULL then the
  counter is decremented atomically when the send is complete.
  
  One counter is for awaiting reuse of local memory and is
  only be used for sbufs which are doing zero copy.  This counter
  provides the mechanism for Longs and non-bulk puts to block before
  they return, and should be allocated as an automatic variable.

  The second counter is for request completion and should be non-NULL
  for every sbuf for which request completion would be checked (all
  puts, but not the Longs).  For the nb and nbi the counter should
  be waited on at sync-time.  This means that the explicit handle is
  probably just the address of a counter (or a struct containing one).
  
+ Similar to the reference implementation's cut-off between Mediums
  (which typically do a source-side copy) and Longs (which may not),
  we have a cut-off size, below which the RDMA-put operation will do
  source-side copies _iff_ local completion is desired (Long, put_nb,
  and put_nbi).

+ The gets are done w/ RDMA-reads, and use the sbuf bounce buffers
  if the local memory is not in the segment (or otherwise registered).
  The value gets will also though the bounce buffers.  Clearly there
  is no bulk/non-bulk distinction in terms of local memory reuse, just
  the alignment and optimal size distinctions.  So, only the outstanding
  request counter on the sbuf is needed for synchronization in all cases.

+ Table of when synchronization is needed
	Operation     Local Remote
	--------------------------
	LongAsync       X     X
	Long            I     X

	put_nb          I     S
	put_nbi         I     S
	put_nb_bulk     X     S
	put_nbi_bulk    X     S
	put_nb_val	X     S
	put_nbi_val	X     S
	put             X     I
	put_bulk        X     I
	put_val         X     I

	get_nb		X     S
	get_nbi		X     S
	get_nb_bulk	X     S
	get_nbi_bulk	X     S
	get_nb_val	X     S
	get_nbi_val (DOES NOT EXIST)
	get		X     I
	get_bulk	X     I
	get_val		X     I

   X = Not needed at all (or not even applicable with _val forms)
   I = Needed before (I)nitiating function returns
   S = Needed before (S)ynchronizing function returns

+ Some minor tweaks are used to avoid allocation of counters in
  some cases.
  - For all the functions which require waiting on a counter in the
    initiating function, the counter can be allocated on the stack (as
    an automatic variable).
  - For the implicit-handle forms the request counter is in the
    thread-specific data, possibly in an access-region.
  - For the explicit handle forms the request counter must be allocated
    from some pool, requiring some memory management work.  This is
    done with a modification to the code from the the reference
    implementation, and uses thread-local data to avoid locks.

+ The memsets are be more efficiently implemented as a _local_ memset
  followed by a RDMA put, for small enough sizes.  The cutoff is
  presently the size of one bounce buffer.
  Larger memsets are still done by Active Messages.
  

@ Section: Graceful exits @

On June 24, 2003 vapi-conduit now passes all 9 (I added two recently)
of the cases in testexit.  By "Pass" I mean that the entire gasnet job
(tested up to 8-way across my 4 dual-processor machines) terminates
with no orphans, and with tracing properly finalized (if tracing is
enabled).  On August 11, 2003 the graceful exit code was revised to
send O(N) network traffic in the worstcase, as opposed to the O(N^2)
required in all cases in the first implementation.

Additionally, the exit code is properly propagated through the
bootstrap, to yield a correct exit code for the parallel job as a
whole.  However, there are some corner cases such as non-collective
returns from main() with might not return the correct exit code if a
different MPI is used for bootstrapping (I am using LAM/MPI).

This code is heavily commented, but for the curious, here is a
description of the code.

There are three paths by which an exit request can begin.  The first
is through gasnetc_exit(), which may be called by the user, by the
conduit in certain error cases, and by the default signal handler for
"termination signals".  The second is via a remote exit request,
passed between nodes to ensure full-job termination from
non-collective exits.  The third is via an atexit() handler,
registered by gasnetc_init(), used to catch returns from main() and
user calls to exit().

There are slight variations among the code in these three cases, but
most of the work is common, and is performed by three functions:
gasnetc_exit_head(), gasnetc_exit_body() and gasnetc_exit_tail().  The
first of these, _head, is used to determine the "first" exit and store
its exit code for later use.  This is important because even a
collective exit will involve receiving remote exit requests.  Only if
a remote exit request is received before any local calls to
gasnetc_exit(), should the request handler initiate the exit.  Note
that even in the case of a collective exit it is possible for the
first remote request to arrive before the local gasnetc_exit() call.
However, that is made very unlikely by the timing and is nearly
harmless since the only difference is the raising of SIGQUIT in
response to a remote exit request, which is not done for
locally-initiated ones.

The second common function, _body(), is used to perform the "meat" of
the shutdown.  It begins by ignoring SIGQUIT to avoid re-entrance, and
then blocks all but the first caller in a polling loop to avoid
multiple threads from executing the shutdown code.  Because strange
things can happen if we are trying to shutdown from a signal context,
a signal handler is installed for all the "abort signals".  This
signal handler just calls _exit() with the exit code stored by
_head().  Because we may have problems shutting down if certain locks
were held when a signal arrived, we also install the signal handler
for SIGALRM, and use the alarm() function to bound the time spent
blocked in the shutdown code.  While there is the risk that this alarm
might go off "too soon" if the shutdown has lots of work to do, we can
be certain that the correct exit code is still generated.

Once the signal handlers are established, _body closes down the
tracing and stats gathering and flushes stdout and stderr.  Then _body
calls gasnetc_get_exit_role() to "elect" a master node for the exit.
This is done with an alarm() timer in force.  The use of an "election"
with a timeout ensures that we will exit, even if node 0 is wedged.
The election of a master proceeds by sending a system-category AM
request to node 0, and spinning to wait for a corresponding reply,
which will indicated if the local node is the "master" or a "slave"
in the coordination of the graceful exit.  The logic on node 0
ensures that the first "candidate" is always made the master, not
waiting for multiple AMs to arrive.  Additionally the slave nodes
may, under circumstances described below, know before entering
gasnetc_get_exit_role() that they are slaves, and will not bother
to send an AMRequest to node 0.  In either case gasnetc_get_exit_role()
indicates to _body which role the local node is to assume.

From _body, the single master node will enter gasnetc_exit_master() and
will begin sending an remote exit request (system-category AM, so this
will all work between _init and _attach) to each peer.  Then the master
waits (with timout, of course) for a reply from each peer.  This request
conveys the desired exit code to each node.  It also will wake them out
of a spin-loop, barrier, or other case where they were not yet aware of
the need to exit.  In the handler for the exit request, a node will send
a reply back to the master, so it knows all the nodes are reachable.  It
will set its role to "slave" and, if no exit is in-progress, it will start
the exit proceedure, as described later.  From _body, the slave nodes all
call gasnetc_exit_slave(), which simply spins until the remore exit request
has arrived from the master.

Regardless of whether the sending of exit requests and replies completed
within the timeout, _body proceeds to shutdown the transport and release
the conduit's resources.  This is, again, protected by an alarm() in case
we get wedged.  Once the transport resources are released, _body flushes
stdout and stderr one last time and closes stdin, stdout and stderr.
Finally, _body shuts down its bootstrap support.  If the coordination
was completed within the timeout, then the gasnetc_bootstrapFini()
routine is called indicating that we'll not be making any more calls
to the bootstrap code and expect to exit shortly.  However, if the
coordination did timeout we call gasnetc_bootstrapAbort(exitcode).  This
call is meant to request that the bootstrap terminate our job "with
prejudice" since we failed to coordinate a graceful shutdown on our
own.  We do this to try to avoid orphans, but risk lots of unsightly
error messages and possible loss of our exit code. Assuming we did not
call _bootstrapAbort (which does not return) we finish _body by
canceling our alarm timer and return to our caller.

The final common routine is gasnetc_exit_tail().  This function just
does the last bit of work to terminate the job.  It is not included in
_body because we let the atexit() case terminate "normally" after
_body returns.  However, in the case of exits initiated via
gasnet_exit() or remote exit request we call _tail to complete the
exit.  In _tail we set an atomic variable to wake any threads which
were stuck polling in _body due to being other than the first thread
to enter.  Those threads should eventually wake and also call _tail to
terminate.  After waking any such threads, we send a SIGUSR1 to the
pid which had called gasnet_init().  The corresponding signal handler
just exits with the exit code stored by _head.  This messy step is
needed because while exit() is guaranteed to properly terminate an
entire multi-threaded process (excepting detached threads), no such
assurance is made for _exit().  That is, of course, because the
graceful shutdown of a pthread process is done in an atexit handler,
which _exit() skips.  At least on Linux pthreads I am observing that
without this step, there are sometimes orphan threads left around, or
worse failure to terminate the job if it is the main thread left
running.  (There is some belief that this behavior is a BUG, and should
be explored further.)

Given the routines gasnetc_exit_{head,body,tail}() the code for the
three types of exit are pretty trivial.  In particular, gasnetc_exit()
just calls _head, _body and _tail with no additional logic.  In the
request handler for the exit request AM, we look at the return from
_head to determine if this exit request is the first we've seen
(inclusive of local calls to gasnet_exit() and our atexit handler).  If
it IS the first exit request, then we raise a SIGQUIT, as required by
the GASNet spec, to allow the user's handler to perform its cleanup.
However, to get the most robust exit code we don't want to run the
_body code from a signal handler context if we can avoided it.
Therefore we inspect the signal handler and skip the raise() call if
the handler is the gasnet default handler, SIG_DFL or SIG_IGN.  After
the raise() returns, or is skipped all together, we are certain that
the user's hander, if any, has executed and has NOT called
gasnet_exit().  If a user handler had called gasnet_exit(), then
raise() would not have returned.  So, if we reach the code after the
possible raise(), we proceed to call gasnetc_exit_body() and _tail to
complete the (hopefully) graceful exit of the gasnet job.

It is important to note that if we get a remote exit request that
initiates an exit, then we will never return from the handler.
However, the design of the AM code in VAPI conduit ensures that this
will actually work without deadlock.  For one, we never run handlers
from signal context or with locks held.  Thus we can expect a
"clean" set of locks.  Furthermore, we don't expect to do anything
useful with the network once the request handler calls _body anyway.

The atexit handler just calls _head and _body before returning to
allow the exit to complete.  In this case we have a little problem
with the lack of access to the return code.  Therefore we just pass 0
to _head, which _body then sends in the remote exit requests.
Experience has shown that, at least with LAM/MPI for bootstrap, when
all but one task exits with zero, the single non-zero exit code
becomes the exit code for the parallel job.  Therefore, using zero
here gives the specified exit code from the parallel job for both
collective and non-collective returns from main.

In the best case one node is way ahead of the others and can win the
master election and send remote exit requests before the others attempt
the election.  In this case the coordinated shutdown needs 1 round-trip
for the election, followed by (N-1) round-trips for the remote exit
request/reply, for a total of 2*N AMs sent.

In the worst case all nodes attempt the election at roughly the same time
and a full N round-trips take place for the election, followed by (N-1)
round trips for the remote exit request/reply, for a total of 4*N-2 AMs
sent.

The average case is somewhere between these two.

@ Section: TO DO @

+ Value gets move as follows:
  - From network to bounce buffer
  - From bounce buffer to _gasnet_valget_op_t or automatic variable
  - From memory to return from function
  The bounce buffer is a little harder to eliminate than for the puts,
  unless we can allocate the _gasnet_valget_op_t in pinned memory.  One
  way to do this might be for the _gasnet_valget_op_t to be placed IN
  the bounce buffer, but that creates a problem with long-lived bounce
  buffers with non-blocking gets.  This _will_ work, however, for blocking
  value gets.

+ If I can be sure there are not deadlock problems under RNR conditions,
  the barrier implementation might be improved using a bunch of puts to
  mark the barrier done upon the final notify.  However, the notify
  mechanism will remain AM-based.
  This would involve the notify passing an address (and perhaps rkey) to
  which this put would be done.
  The question remains as to where this memory would come from.  Since we
  only need a small amount, perhaps we can carve it out of the segment?
  Perhaps we just allow the extended ref to allocate pinned memory at
  initialization time and pass the rkey with the address.

+ Can use "notifn" to make the progress thread only wake if there are
  multiple outstanding recvs.  This could, for instance, wake only if
  we reach the RNR state (or maybe are one event shy of it).
 
+ There is DDR memory on the board, which is at least 2.5 times faster
  than host memory from the point-of-view of the network.  The down side
  is that it is both slower and non-cachable from the host.  However, it
  might be sensible to use it for some purposes.  In particular bounce
  buffers don't need to be cachable.  So, the bounce buffers could move
  to the HCA.

  I speculate that the result could be an increase in overhead, due to
  the host-copy going to slower memory.  However, I expect that the total
  end-to-end latency may be reduced slightly and less cache pollution will
  occur.  Additionally the "background" copy by the HCA will not cause
  traffic on either the PCI or memory bus - reducing resource contention
  during the time one may wish to overlap computation.

    PUT Case I: 
      CPU copies host_mem->host_mem
      HCA copies host_mem->HCA_mem
      HCA sends from HCA_mem to network
    PUT Case II:
      CPU copies host_mem->HCA_mem
      HCA copies HCA_mem->HCA_mem (Might be omitted?)
      HCA sends from HCA_mem to network
 
    GET Case I:
      HCA recvs to HCA_mem
      HCA copies HCA_mem->host_mem
      CPU copies host_mem->host_mem
    GET Case II:
      HCA recvs to HCA_mem
      HCA copies HCA_mem->HCA_mem (Might be omitted?)
      CPU copies HCA_mem->host_mem

  Of course I can't get a program to allocate from HCA memory!

+ Adaptive flow-control for AMs.
  In this mode we'd prepost just M recv buffer to each QP if we want to
  have up to M AM's outstanding per peer, rather than 2*M as we do now.
  The present use of 2*M ensures one available for each matching reply
  (though coming in the opposite direction).  Since the buffers for the
  replies are needed LOCALLY, we can be adaptive and post one extra
  buffer before each AM request rather than preposting them.
  We need to maintain a shared pool of these unposted buffers and be
  prepared to poll for them to become available along with polling
  for available credits.

+ Implement a firehose-page client for VAPI to do SEGMENT_EVERYTHING.
  Once that works, I need to implement firehose-region instead.

+ Learn more about VAPI "fast memory regions" and how they differ from
  normal memory registration.  This may be vital to a decent implementation
  of the firehose algorithm(s).
