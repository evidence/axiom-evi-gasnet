README file for vapi-conduit
================================
Paul H. Hargrove <PHHargrove@lbl.gov>

@ TOC: @
@ Section: Build-time Configuration @
@ Section: Runtime Configuration @
@ Section: Core API @
@ Section: Extended API @
@ Section: Graceful exits @
@ Section: TO DO @


@ Section: Build-time Configuration @
  There are two known bugs in older InfiniHost firmware versions.
  Normally you shouldn't need to do anything special with regards
  to them.  However, if you do need to override the defaults this
  section explains the issues.

  + Thread safety of VAPI_poll_cq()
    In firmware versions prior to 3.0, the VAPI_poll_cq() call is
    not thread safe under some conditions.  For this reason,
    vapi-conduit will check the firmware version at runtime and will
    use its own mutex around calls to VAPI_poll_cq() if needed.

    If you believe this bug is appearing in firmware 3.0 or later,
    you can force use of this mutex by configuring GASNet with the
    flag '--enable-vapi-force-poll-lock'.

  + Performance loss in EVAPI_post_inline_sr()
    In firmware versions after 1.17 and prior to 3.0, there is a
    performance anomaly with the call EVAPI_post_inline_sr().
    By default, vapi-conduit will use this call to perform small
    puts.  If firware in the range [1.18, 3.0) is detected at
    runtime, a warning will be printed but the call will still
    be used.

    If you believe this bug is affecting your performance under
    other firmware versions, or to silence this warning without
    updating your firmware, configure GASNet with the flag
    '--disable-vapi-inline-puts'.  This will disable the use of
    the EVAPI_post_inline_sr() call, and disable the warning.
    
@ Section: Runtime Configuration @

  There are a number of parameters in vapi-conduit which can be tuned
  at runtime via environment variables.  There are two categories of
  parameters: connection settings and resource usage parameters.

  Connection settings:
  + GASNET_HCA_ID
    This gives the "HCA ID" string of the InfiniBand Host Channel
    Adapter (HCA) to open.  This string is assigned by the device driver
    at boot time.  A typical HCA ID is "InfiniHost0", for the first HCA
    with the InfiniHost chip.
    The default value is an empty string, which causes vapi-conduit to
    try all HCAs detected by the device driver and use the first one
    which can be opened.
    This parameter may meaningfully be different on each node.

  + GASNET_PORT_NUM
    This gives the integer port number to use on the HCA.  The "port"
    is a physical port on the HCA, not to be confused with IP port
    numbers.  IB defines the port numbers to start at 1.
    The default value is 0, which causes vapi-conduit to probe the HCA
    for the lowest-numbered physical port which is configured as ACTIVE.
    This parameter may meaningfully be different on each node.

  Resource usage parameters:
  + GASNET_OP_OUST_PP
    This gives the maximum number of outstanding ops (RDMA + AMs) which
    can be in-flight simultaneously from a node to each of its peers.
    Here "in-flight" means queued to the send work queue and not yet
    reaped from the send completion queue.  Note that these operations
    are reaped in FIFO order, independent of when any corresponding
    GASNet operation is synced.
    This value is the depth of each send work queue.  Thus the memory
    consumed for send work queues scales as GASNET_OP_OUST_PP*(N-1),
    on each node.
    The default value is 64.
    This parameter should be equal across all nodes, and the behavior
    otherwise is undefined.

  + GASNET_OP_OUST_LIMIT
    This gives the maximum number of outstanding ops (RDMA + AMs) which
    can be in-flight simultaneously from each node, with "in-flight"
    defined as in GASNET_OP_OUST_PP.
    This is (potentially) the depth of the send completion queue and the
    number of 'sbuf' data structures allocated to track in-flight ops.
    However, for a given value of GASNET_OP_OUST_PP and N, it might not
    be possible to launch GASNET_OP_OUST_LIMIT operations.  Therefore,
    the memory consumed for the send completion queue and sbufs scales
    as min(GASNET_OP_OUST_LIMIT, GASNET_OP_OUST_PP*(N-1)), on each node.
    The default value is 1024.  (upto 4MB used for send buffers)
    This parameter should be equal across all nodes, and the behavior
    otherwise is undefined.
   
  + GASNET_AM_OUST_PP
    This give the maximum number of outstanding AM Requests which can
    be in-flight simultaneously from a node to each of its peers.  Here
    "in-flight" means the Request is queued to the send work queue, but
    the matching Reply has not yet been processed for AM flow control
    (described in another section of this README).
    This is the number of receive buffers which must be preposted to each
    endpoint for AM Requests.  With the current flow-control scheme the
    same number of additional receive buffers are needed to accept replies.
    Thus, the memory consumed for the receive work queues and the receive
    completion queue each scale as GASNET_AM_OUST_PP*(N-1) on each node.
    The default value is 32.  (256KB*(N-1) for receive buffers)
    This parameter should be equal across all nodes, and the behavior
    otherwise is undefined.

  + GASNET_AM_OUST_LIMIT
    This give the integer number of outstanding AM Requests which can
    be in-flight simultaneously from each node, with "in-flight" defined
    as in GASNET_AM_OUST_PP.
    With the current flow-control scheme this parameter is not yet fully
    implemented.  Intended to control the size of the receive completion
    queue, this parameter will be used with the "dynamic flow-control"
    scheme (elsewhere in this README).  For now it is an error to set
    this parameter to anything smaller than GASNET_AM_OUST_PP*(N-1), and
    values larger than that are clipped to this value.
    The default is 32767, and represents the limit of 65535 completion
    queue entries supported by the InfiniHost firmware.
    This parameter should be equal across all nodes, and the behavior
    otherwise is undefined.

  + GASNET_AM_SPARES
    This gives the number of "spare" receive buffers which are allocated
    in addition to those needed to satisfy the settings of the parameters
    GASNET_AM_OUST_PP and GASNET_AM_OUST_LIMIT.  These spare receive
    buffers are used while running AM handlers, to aid the flow-control
    process.
    Because a "spare" receive buffer is used while an AM handler is
    running, this parameter limits the number of AM handlers which can
    run concurrently without running the risk of an empty receive work
    queue.  As described in the section on AM flow-control the empty
    queue condition is undesirable, but not fatal.  Since a given thread
    can only run one handler at a time, values of GASNET_AM_SPARES
    larger than the number of threads running concurrently in GASNet
    offer no extra benefit.  So, the default value depends on the
    threading configuration.
    When compiled for GASNET_PARSYNC or GASNET_SEQ, the default is 2
    to allow for a single client thread in GASNet plus the internal AM
    receive thread.  When compiled for GASNET_PAR, the default is 4.
    This parameter should be equal across all nodes, and the behavior
    otherwise is undefined.

@ Section: Core API @

+ Flow-control for AMs.

  The AMs in vapi-conduit are just implemented as send/recv traffic.
  Therefore a send without a corresponding recv buffer preposted at the
  peer will be stalled by the RNR (receiver-not-ready) flow control
  in IB.  However there are two reasons why we want to avoid this
  situation.  The first is that if such a send is blocked by flow
  control, then the ordering semantics of IB tell us that all the
  gets and puts that we've initiated after the AM was sent are also
  stalled.  Rather than let that happen, we should manually delay
  those which are dependent on the AM.  The second reason is that
  under some conditions the RNR flow control is very poor.  The problem
  is that once the intended receiver sends a RNR NAK to indicate no
  available recv buffers, IB has the SENDER's hardware/firmware poll
  for the receiver to become ready again!  That leaves us with a choice
  between configuring a small polling interval and consuming a lot of
  bandwidth for this polling, or a large interval which leads to more
  performance which is degraded more than necessary when IB flow control
  is asserted.

  For these reasons we implement some flow control at the AM level.
  The basic idea is that every REQUEST consumes one credit on the
  sending endpoint and every REPLY grants one credit on the receiving
  endpoint.  Thus if M is the initial number of credits on each endpoint
  and every REQUEST has exactly one matching REPLY, then M becomes a
  limit on the number of un-acknowledged REQUESTS in flight on an
  endpoint.  If we want to avoid RNR conditions, then we should start
  with M credits and 2*M preposted recv buffers on each endpoint.  The
  factor of 2 is because we can consume M of the buffers on the peer's
  endpoint with out REQUESTs and an additional M for REPLYs to her
  REQUESTS.

  It is a simple matter to count the credits when a REPLY is received
  and to poll for credits when needed to send a REQUEST.  It is also
  simple to ensure the exactly-one-reply.  We already ensure that
  at-most-one reply is sent by the request handler.  Additionally we
  must check upon handler return for the case that the request hander
  sent no reply, and send one implicitly.  We just use a special
  "system category" handler, gasnetc_SYS_ack, which doesn't even run
  a handler.

  To avoid a window of time between when we send a reply (credit) and
  when we post the recv buffer, we must post the replacement recv
  buffer BEFORE running the AM REQUEST handler.  To do this we keep a
  pool of unposted recv buffers.  So, when we recv a REQUEST, we grab
  a free recv buffer from the pool and post it to the endpoint, run
  the handler, send an implicit reply if the handler didn't send any
  and finally we take the recv buffer containing the REQUEST and we
  return it to the unposted pool.  When get recv a REPLY we don't
  bother with as much complication, and just repost the recv buffer
  holding the REQUEST, after running the handler.

  There is a corner case we must deal with when there are no spares
  left in the unposted pool.  In this case we will allow IB's RNR
  flow control to kick-in in the unlikely event of a race.  When
  there are no spares remaining, we delay reposting a recv buffer to
  the endpoint until after the hander has run.  If the recv buffer
  of which the replacement is delayed triggers a REQUEST handler 
  then there is a potential race, because the credit update implied
  by the reply (explicit or implicit) precedes the replacement.
  Here is what is needed to trigger IB's RNR flow control:
  1) Assume that all the recv buffers posted to the endpoint have
     been consumed by AMs
  2) Assume the current AM is a request
  3) When the request handler sends a reply, or the system sends a
     reply after the handler terminates...
  4) The peer receives the reply and thus receives a credit
  5) The credit allows the peer to send us another AM request
  6) This additional request arrives before the current recv buffer
     is reposted to the endpoint
  7) The HCA is unable to complete the transfer of the new AM request
     until the current recv buffer is reposted.
  8) IB's RNR (Reciever Not Ready) flow-control kicks in, stalling our
     peer's send queue
  Fortunately this is not only unlikely, it is also non-fatal.
  Eventually, the recv buffer will be reposted and the stall will end.
  However, the point-to-point ordering guarantees of IB ensure that all
  the transfers queued behind the stalled AM request are also stalled.
  
  If we reap multiple REQUESTS in a single Poll, then we reuse the
  previous buffer as the "spare" for the next one, in place of
  grabbing one from the unposted pool each time.  Thus, we touch the
  unposted pool at most twice per Poll, once for the first REQUEST we
  receive and once at the end to put the recv buffer of the final
  REQUEST back in the unposted pool.  For the dedicated receive thread
  we do even better, never touching the unposted pool at all by always
  keeping a single thread-local "spare", initially acquired at startup.

  At present there is some incomplete support for allowing system-level
  AMs to break the request-reply model and go request-reply-request or
  request-reply-request-reply.  This would be done by having the first
  request allocate 2 credits and having the second allocate none.  Note
  that these two patterns are actually the same, due to the implicit
  reply sent back in the first case to perform the credit update.  We
  are still missing code to allocate multiple credits without causing
  wither deadlock or livelock.  Also missing is the actual _need_ for
  this.  Once the firehose client is implemented I'll determine need to
  either complete the support for this messaging pattern, or remove the
  partial support to simplify the code paths.
  Note that this is independent of allowing handlers to initiate RDMA.

@ Section: Extended API @

Notes for myself for extended API:

+ The send completion facility consists of two pointers to counters,
  associated with each sbuf.  If these pointers are non-NULL then the
  counter is decremented atomically when the send is complete.
  
  One counter is for awaiting reuse of local memory and is
  only be used for sbufs which are doing zero copy.  This counter
  provides the mechanism for Longs and non-bulk puts to block before
  they return, and should be allocated as an automatic variable.

  The second counter is for request completion and should be non-NULL
  for every sbuf for which request completion would be checked (all
  gets & puts, but not the Longs).  For nb and nbi the counter is
  waited on at sync-time.  Therefore the explicit handle is a struct
  containing the counter.
  
+ Similar to the reference implementation's cut-off between Mediums
  (which typically do a source-side copy) and Longs (which may not),
  we have a cut-off size, below which the RDMA-put operation will do
  source-side copies _iff_ local completion is desired (Long, put_nb,
  and put_nbi).

+ The gets are done w/ RDMA-reads, and use the sbuf bounce buffers
  if the local memory is not in the segment (or otherwise registered).
  The value gets will also though the bounce buffers.  Clearly there
  is no bulk/non-bulk distinction in terms of local memory reuse, just
  the alignment and optimal size distinctions.  So, only the outstanding
  request counter on the sbuf is needed for syncs of all types of gets.

+ Table of when synchronization is needed
	              Local Remote
	Operation     Sync  Sync
	--------------------------
	LongAsync       X     X
	Long            I     X

	put_nb          I     S
	put_nbi         I     S
	put_nb_bulk     X     S
	put_nbi_bulk    X     S
	put_nb_val	X     S
	put_nbi_val	X     S
	put             X     I
	put_bulk        X     I
	put_val         X     I

	get_nb		X     S
	get_nbi		X     S
	get_nb_bulk	X     S
	get_nbi_bulk	X     S
	get_nb_val	X     S
	get_nbi_val (DOES NOT EXIST)
	get		X     I
	get_bulk	X     I
	get_val		X     I

   X = Not needed at all (or not even applicable with _val forms)
   I = Needed before (I)nitiating function returns
   S = Needed before (S)ynchronizing function returns

+ Some minor tweaks are used to avoid allocation of counters in
  some cases.
  - For all the functions which require waiting on a counter in the
    initiating function, the counter can be allocated on the stack (as
    an automatic variable).
  - For the implicit-handle forms the request counter is in the
    thread-specific data, possibly in an access-region.
  - For the explicit handle forms the request counter must be allocated
    from some pool, requiring some memory management work.  This is
    done with a modification to the code from the the reference
    implementation, and uses thread-local data to avoid locks.

+ The memsets are be more efficiently implemented as a _local_ memset
  followed by a RDMA put, for small enough sizes.  The cutoff is
  presently the size of one bounce buffer.
  Larger memsets are still done by Active Messages.
  

@ Section: Graceful exits @

On June 24, 2003 vapi-conduit now passes all 9 (I added two recently)
of the cases in testexit.  By "Pass" I mean that the entire gasnet job
(tested up to 8-way across my 4 dual-processor machines) terminates
with no orphans, and with tracing properly finalized (if tracing is
enabled).  On August 11, 2003 the graceful exit code was revised to
send O(N) network traffic in the worst case, as opposed to the O(N^2)
required in all cases in the first implementation.

Additionally, the exit code is properly propagated through the
bootstrap, to yield a correct exit code for the parallel job as a
whole.  However, there are some corner cases such as non-collective
returns from main() with might not return the correct exit code if a
different MPI is used for bootstrapping (I am using LAM/MPI).

This code is heavily commented, but for the curious, here is a
description of the code.

There are three paths by which an exit request can begin.  The first
is through gasnetc_exit(), which may be called by the user, by the
conduit in certain error cases, and by the default signal handler for
"termination signals".  The second is via a remote exit request,
passed between nodes to ensure full-job termination from
non-collective exits.  The third is via an atexit() handler,
registered by gasnetc_init(), used to catch returns from main() and
user calls to exit().

There are slight variations among the code in these three cases, but
most of the work is common, and is performed by three functions:
gasnetc_exit_head(), gasnetc_exit_body() and gasnetc_exit_tail().  The
first of these, _head, is used to determine the "first" exit and store
its exit code for later use.  This is important because even a
collective exit will involve receiving remote exit requests.  Only if
a remote exit request is received before any local calls to
gasnetc_exit(), should the request handler initiate the exit.  Note
that even in the case of a collective exit it is possible for the
first remote request to arrive before the local gasnetc_exit() call.
However, that is made very unlikely by the timing and is nearly
harmless since the only difference is the raising of SIGQUIT in
response to a remote exit request, which is not done for
locally-initiated ones.

The second common function, _body(), is used to perform the "meat" of
the shutdown.  It begins by ignoring SIGQUIT to avoid re-entrance, and
then blocks all but the first caller in a polling loop to avoid
multiple threads from executing the shutdown code.  Because strange
things can happen if we are trying to shutdown from a signal context,
a signal handler is installed for all the "abort signals".  This
signal handler just calls _exit() with the exit code stored by
_head().  Because we may have problems shutting down if certain locks
were held when a signal arrived, we also install the signal handler
for SIGALRM, and use the alarm() function to bound the time spent
blocked in the shutdown code.  While there is the risk that this alarm
might go off "too soon" if the shutdown has lots of work to do, we can
be certain that the correct exit code is still generated.

Once the signal handlers are established, _body closes down the
tracing and stats gathering and flushes stdout and stderr.  Then _body
calls gasnetc_get_exit_role() to "elect" a master node for the exit.
This is done with an alarm() timer in force.  The use of an "election"
with a timeout ensures that we will exit, even if node 0 is wedged.
The election of a master proceeds by sending a system-category AM
request to node 0, and spinning to wait for a corresponding reply,
which will indicated if the local node is the "master" or a "slave"
in the coordination of the graceful exit.  The logic on node 0
ensures that the first "candidate" is always made the master, not
waiting for multiple AMs to arrive.  Additionally the slave nodes
may, under circumstances described below, know before entering
gasnetc_get_exit_role() that they are slaves, and will not bother
to send an AMRequest to node 0.  In either case gasnetc_get_exit_role()
indicates to _body which role the local node is to assume.

From _body, the single master node will enter gasnetc_exit_master() and
will begin sending an remote exit request (system-category AM, so this
will all work between _init and _attach) to each peer.  Then the master
waits (with timeout, of course) for a reply from each peer.  This request
conveys the desired exit code to each node.  It also will wake them out
of a spin-loop, barrier, or other case where they were not yet aware of
the need to exit.  In the handler for the exit request, a node will send
a reply back to the master, so it knows all the nodes are reachable.  It
will set its role to "slave" and, if no exit is in-progress, it will start
the exit procedure, as described later.  From _body, the slave nodes all
call gasnetc_exit_slave(), which simply spins until the remote exit request
has arrived from the master.

Regardless of whether the sending of exit requests and replies completed
within the timeout, _body proceeds to shutdown the transport and release
the conduit's resources.  This is, again, protected by an alarm() in case
we get wedged.  Once the transport resources are released, _body flushes
stdout and stderr one last time and closes stdin, stdout and stderr.
Finally, _body shuts down its bootstrap support.  If the coordination
was completed within the timeout, then the gasnetc_bootstrapFini()
routine is called indicating that we'll not be making any more calls
to the bootstrap code and expect to exit shortly.  However, if the
coordination did timeout we call gasnetc_bootstrapAbort(exitcode).  This
call is meant to request that the bootstrap terminate our job "with
prejudice" since we failed to coordinate a graceful shutdown on our
own.  We do this to try to avoid orphans, but risk lots of unsightly
error messages and possible loss of our exit code. Assuming we did not
call _bootstrapAbort (which does not return) we finish _body by
canceling our alarm timer and return to our caller.

The final common routine is gasnetc_exit_tail().  This function just
does the last bit of work to terminate the job.  It is not included in
_body because we let the atexit() case terminate "normally" after
_body returns.  However, in the case of exits initiated via
gasnet_exit() or remote exit request we call _tail to complete the
exit.  In _tail we set an atomic variable to wake any threads which
were stuck polling in _body due to being other than the first thread
to enter.  Those threads should eventually wake and also call _tail to
terminate.  Next, we call gasneti_killmyprocess() to do any platform-
specific magic required to get the entire multithreaded application to
exit.  Finally we call _exit() with the saved exit code.

Given the routines gasnetc_exit_{head,body,tail}() the code for the
three types of exit are pretty trivial.  In particular, gasnetc_exit()
just calls _head, _body and _tail with no additional logic.  In the
request handler for the exit request AM, we look at the return from
_head to determine if this exit request is the first we've seen
(inclusive of local calls to gasnet_exit() and our atexit handler).  If
it IS the first exit request, then we raise a SIGQUIT, as required by
the GASNet spec, to allow the user's handler to perform its cleanup.
However, to get the most robust exit code we don't want to run the
_body code from a signal handler context if we can avoided it.
Therefore we inspect the signal handler and skip the raise() call if
the handler is the gasnet default handler, SIG_DFL or SIG_IGN.  After
the raise() returns, or is skipped all together, we are certain that
the user's hander, if any, has executed and has NOT called
gasnet_exit().  If a user handler had called gasnet_exit(), then
raise() would not have returned.  So, if we reach the code after the
possible raise(), we proceed to call gasnetc_exit_body() and _tail to
complete the (hopefully) graceful exit of the gasnet job.

It is important to note that if we get a remote exit request that
initiates an exit, then we will never return from the handler.
However, the design of the AM code in VAPI conduit ensures that this
will actually work without deadlock.  For one, we never run handlers
from signal context or with locks held.  Thus we can expect a
"clean" set of locks.  Furthermore, we don't expect to do anything
useful with the network once the request handler calls _body anyway.

The atexit handler just calls _head and _body before returning to
allow the exit to complete.  In this case we have a little problem
with the lack of access to the return code.  Therefore we just pass 0
to _head, which _body then sends in the remote exit requests.
Experience has shown that, at least with LAM/MPI for bootstrap, when
all but one task exits with zero, the single non-zero exit code
becomes the exit code for the parallel job.  Therefore, using zero
here gives the specified exit code from the parallel job for both
collective and non-collective returns from main.

In the best case one node is way ahead of the others and can win the
master election and send remote exit requests before the others attempt
the election.  In this case the coordinated shutdown needs 1 round-trip
for the election, followed by (N-1) round-trips for the remote exit
request/reply, for a total of 2*N AMs sent.

In the worst case all nodes attempt the election at roughly the same time
and a full N round-trips take place for the election, followed by (N-1)
round trips for the remote exit request/reply, for a total of 4*N-2 AMs
sent.

The average case is somewhere between these two.

@ Section: TO DO @

+ Value gets move as follows:
  - From network to bounce buffer
  - From bounce buffer to _gasnet_valget_op_t or automatic variable
  - From memory to return from function
  The bounce buffer is a little harder to eliminate than for the puts,
  unless we can allocate the _gasnet_valget_op_t in pinned memory.  One
  way to do this might be for the _gasnet_valget_op_t to be placed IN
  the bounce buffer, but that creates a problem with long-lived bounce
  buffers with non-blocking gets.  This _will_ work, however, for blocking
  value gets.

+ If I can be sure there are not deadlock problems under RNR conditions,
  the barrier implementation might be improved using a bunch of puts to
  mark the barrier done upon the final notify.  However, the notify
  mechanism will remain AM-based.
  This would involve the notify passing an address (and perhaps rkey) to
  which this put would be done.
  The question remains as to where this memory would come from.  Since we
  only need a small amount, perhaps we can carve it out of the segment?
  Perhaps we just allow the extended ref to allocate pinned memory at
  initialization time and pass the rkey with the address.

+ Can use "notifn" to make the progress thread only wake if there are
  multiple outstanding recvs.  This could, for instance, wake only if
  we reach the RNR state (or maybe are one event shy of it).
 
+ There is DDR memory on the board, which is at least 2.5 times faster
  than host memory from the point-of-view of the network.  The down side
  is that it is both slower and non-cachable from the host.  However, it
  might be sensible to use it for some purposes.  In particular bounce
  buffers don't need to be cachable.  So, the bounce buffers could move
  to the HCA.

  I speculate that the result could be an increase in overhead, due to
  the host-copy going to slower memory.  However, I expect that the total
  end-to-end latency may be reduced slightly and less cache pollution will
  occur.  Additionally the "background" copy by the HCA will not cause
  traffic on either the PCI or memory bus - reducing resource contention
  during the time one may wish to overlap computation.

    PUT Case I: 
      CPU copies host_mem->host_mem
      HCA copies host_mem->HCA_mem
      HCA sends from HCA_mem to network
    PUT Case II:
      CPU copies host_mem->HCA_mem
      HCA copies HCA_mem->HCA_mem (Might be omitted?)
      HCA sends from HCA_mem to network
 
    GET Case I:
      HCA recvs to HCA_mem
      HCA copies HCA_mem->host_mem
      CPU copies host_mem->host_mem
    GET Case II:
      HCA recvs to HCA_mem
      HCA copies HCA_mem->HCA_mem (Might be omitted?)
      CPU copies HCA_mem->host_mem

  Of course I can't get a program to allocate from HCA memory!

+ Adaptive flow-control for AMs.
  In this mode we'd prepost just M recv buffer to each QP if we want to
  have up to M AM's outstanding per peer, rather than 2*M as we do now.
  The present use of 2*M ensures one available for each matching reply
  (though coming in the opposite direction).  Since the buffers for the
  replies are needed LOCALLY, we can be adaptive and post one extra
  buffer before each AM request rather than preposting them.
  We need to maintain a shared pool of these unposted buffers and be
  prepared to poll for them to become available along with polling
  for available credits.

+ Implement a firehose-page client for VAPI to do SEGMENT_EVERYTHING.
  Once that works, I need to implement firehose-region instead.

+ Learn more about VAPI "fast memory regions" and how they differ from
  normal memory registration.  This may be vital to a decent implementation
  of the firehose algorithm(s).
