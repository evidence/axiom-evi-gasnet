\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename gasnet.info
@settitle GASNet Specification
@syncodeindex tp fn

@c -DNOTEXHACKS turns off (potentially non-portable) Tex/Texinfo formatting hacks
@ifclear NOTEXHACKS
@iftex
@c @pagesizes 7.5in,10in
@tex
\globaldefs =1

% set some sane page margins

% (from texinfo.tex) Parameters in order: 1) textheight; 2) textwidth; 3) voffset;
% 4) hoffset; 5) binding offset; 6) topskip.  Then whoever calls us can
% set \parskip and call \setleading for \baselineskip.
\parskip 1ex
\internalpagesizes{10in}{7.5in}{-.5in}{-.5in}{0in}{0in}

% override the stupid extra spacing before deftypefn's

\def\defmethparsebody#1#2#3#4 {\begingroup\inENV %
\smallskip
%\medbreak %
\def#1{\endgraf\endgroup\medbreak}%
\def#2##1 {\begingroup\obeylines\activeparens\spacesplit{#3{##1}}}%
\parindent=0in                                                
\advance\leftskip by \defbodyindent
\exdentamount=\defbodyindent
\begingroup\obeylines\activeparens\spacesplit{#3{#4}}}

\globaldefs = 0
@end tex
@end iftex
@end ifclear

@c %**end of header
@c ------------------------------------------------------------------------------------
@c Macros:

@set VERSION 0.7draft1
@set RELEASEDATE July 2nd, 2002

@ifnottex
@ifhtml
@set HTMLORTEXT
@end ifhtml
@ifplaintext
@set HTMLORTEXT
@end ifplaintext
@end ifnottex

@c -DNO_NOTES turns off implementor's notes
@ifset NONOTES
@macro IMPNOTE{arg}
@c
@end macro
@end ifset

@ifclear NONOTES
@macro IMPNOTE {text}
@cartouche
@ifhtml
@html
<table border="1" width="100%"><tr><td width="100%">
@end html
@end ifhtml
@strong{Implementor's Note:}
@itemize @bullet
\text\
@end itemize
@ifhtml
@html
</td></tr></table>
@end html
@end ifhtml
@end cartouche
@end macro
@end ifclear

@macro FNH {name}
@node \name\
@subsubsection \name\
@c This comment list is required, for some unknown reason
@end macro

@macro FNI {name}
@findex \name\
@c This comment list is required, for some unknown reason
@end macro

@macro FN {name}
@node \name\
@subsubsection \name\
@findex \name\
@c This comment list is required, for some unknown reason
@end macro

@macro HR
@ifnottex
@ifhtml
@html
<hr>
@end html
@end ifhtml
@ifplaintext
------------------------------------------------------------------------------------
@end ifplaintext
@end ifnottex
@end macro

@c ------------------------------------------------------------------------------------
@c keywords for install-info:
@ifnottex
@ifnotplaintext
@ifinfo
@dircategory GASNet Specification
@direntry
* GASNet specification, version @value{VERSION}: (gasnet).   The GASNet communication spec
@end direntry
@end ifinfo
@end ifnotplaintext
@end ifnottex
@c ------------------------------------------------------------------------------------

@macro COPYRIGHTTEXT
Copyright @copyright{} 2002, Dan Bonachea.@*
Selected portions adapted from:
@itemize @bullet
@item @cite{A. Mainwaring and D. Culler, "Active Message Applications Programming Interface and Communication Subsystem Organization", U.C. Berkeley Computer Science Technical Report, 1996.}
@item @cite{D. Culler et al., "Generic Active Message Interface Specification v1.1", U.C. Berkeley Computer Science Technical Report, Feb, 1995.}
@end itemize

@quotation
Permission is granted to freely distribute this specification and use it in 
creating GASNet clients or implementations. The authoritative version of the GASNet specification
is maintained by Dan Bonachea and any proposed changes should be submitted for review.
@end quotation

Published by LBNL NERSC FTG and U.C. Berkeley
@end macro

@titlepage
@title GASNet Specification
@subtitle Version @value{VERSION}
@subtitle Released @value{RELEASEDATE}
@subtitle $Date: 2002/08/02 09:07:48 $
@subtitle Printed @today{}
@subtitle $Revision: 1.7 $ 
@author Editor: Dan Bonachea @email{bonachea@@cs.berkeley.edu}
@uref{http://upc.nersc.gov/}

@c  The following two commands
@c  start the copyright page.
@page
@vskip 0pt plus 1filll

@ifnottex
@copying
@end ifnottex
This the GASNet specification, version @value{VERSION}.

@COPYRIGHTTEXT
@ifnottex
@end copying
@insertcopying
@end ifnottex
@end titlepage

@c ------------------------------------------------------------------------------------
@c So the toc is printed in the right place.
@ifclear HTMLORTEXT
@contents
@c @shortcontents
@end ifclear

@ifnottex
@node Top
@top GASNet Specification

@insertcopying
@end ifnottex

@c HTML/Plain text title info
@ifset HTMLORTEXT
Version @value{VERSION}
@*Released @value{RELEASEDATE}
@*$Date: 2002/08/02 09:07:48 $
@*$Revision: 1.7 $ 
@*Editor: Dan Bonachea @email{bonachea@@cs.berkeley.edu}
@*@uref{http://upc.nersc.gov/}
@HR
@COPYRIGHTTEXT
@HR
@end ifset


@menu
* Introduction::  
* Core API::
* Extended API::  
* Appendix::
* Concept Index::         
* Function Macro and Type Index::         
@end menu

@c ------------------------------------------------------------------------------------
@node Introduction
@chapter Introduction
@cindex Introduction
@cindex GASNet organization
@cindex UPC
@cindex Titanium

@section Scope
This GASNet specification describes a network-independent and 
language-independent high-performance communication interface intended for use in 
implementing the runtime system for global address space languages (such as 
UPC or Titanium). GASNet stands for 
"@strong{G}lobal-@strong{A}ddress @strong{S}pace @strong{Net}working".

@section Organization
The interface is divided into 2 layers - the GASNet core API and the GASNet 
extended API:

@itemize @bullet
@item
@cindex Extended API
The extended API is a richly expressive and flexible interface that 
provides medium and high-level operations on remote memory and collective 
operations (basically anything that we could imagine being implemented using 
hardware support on some NIC's).

@item
@cindex Core API
The core API is a narrow interface based on the Active Messages paradigm, 
which is general enough to implement everything in the extended API. 
@end itemize

The core API is the minimum interface that must be implemented on each 
network when porting to a new system, and we provide a network-independent 
reference implementation of the extended API which is written purely in 
terms of the core API to ease porting and quick prototyping. Implementors 
for NIC's that provide some hardware support for higher-level messaging 
operations (e.g. support for servicing remote reads/writes on the NIC 
without involving the main CPU) are encouraged to also implement an 
appropriate subset of the extended API directly on the network of interest 
(bypassing the core API) to achieve maximal performance for those operations 
(but this is an optimization and is not required to have a working system). 
Most clients will use calls to the extended API functions to implement the 
bulk of their communication work (thereby ensuring optimal performance 
across platforms). However the client is also permitted to use the core 
active message interface to implement non-trivial language-specific or 
compiler-specific communication operations which would not be appropriate in 
a language-independent API (e.g. implementing distributed language-level 
locks, distributed garbage collection, collective memory allocation, etc.).

Note the extended API interface is meant primarily as a low-level 
compilation target, not a library for hand-written code - as such, the goals 
of expressiveness and performance generally take precedence over readability 
and minimality. 

@c ------------------------------------------------------------------------------------
@section Conventions
@cindex Conventions

@itemize @bullet
@item All GASNet entry points are lower-case identifiers with the prefix @code{gasnet_} 
@item All constants are upper-case and preceded with the prefix @code{GASNET_}
@item Clients access the GASNet interface by including the header @file{gasnet.h} and 
linking the appropriate library
@item Except where otherwise noted, any of the operations in the GASNet 
interface could be implemented using macros or inline functions in an actual 
implementation - they are specified using function declaration syntax below 
to make the types clear, and all correct client code must type check using 
the definitions below. In no case should client code assume it can create a 
"function pointer" to any of these operations. Any macro implementations 
will ensure that arguments are evaluated exactly once.
@item Implementation-specific values in declarations are indicated using "???"
@item Sections marked "Implementor's note" are recommendations to implementors 
and are not part of the specification
@end itemize

@c ------------------------------------------------------------------------------------
@page
@section Definitions

@itemize @bullet
@cindex node
@item
@strong{node} - An OS-level process which returns from @code{gasnet_init()}, and its associated 
local memory space and system resources. The basic unit of control when 
interfacing with GASNet.

@item
@cindex thread
@strong{thread} - A single thread of control within a GASNet node, which possibly 
shares a virtual memory space and OS-level process-id with other threads in 
the node. Clients which may concurrently call GASNet from more than a single 
thread must compile to the multi-threaded version of the GASNet library. 
Except where otherwise noted, GASNet makes no distinction between the 
threads within a multi-threaded node, and all control functions (e.g. 
barriers) should be executed by a single thread on the node on behalf of all 
local threads.

@item
@cindex job
@strong{job} - The collection of nodes making up a parallel execution environment. 
Nodes often correspond to physical, architectural units, but this need not 
be the case (e.g. nodes may share a physical CPU/memory/NIC in 
multiprogrammed systems with sufficient sharable resources - note that some 
GASNet implementations may limit the number nodes which can run concurrently 
on a single system based on the number of physical network interfaces)
@end itemize
@c ------------------------------------------------------------------------------------
@section Configuration of GASNet
@cindex Configurations

Client code must @code{#define} exactly one of @code{GASNET_PAR}, @code{GASNET_PARSYNC} or 
@code{GASNET_SEQ} when compiling the GASNet library and the client code (before 
including @file{gasnet.h}) to indicate the threading environment. 

@ftable @code
@item GASNET_PAR
The most general configuration. Indicates a fully multi-threaded 
and thread-safe environment - the client may call GASNet 
concurrently from more than one thread. The exact threading system in use is 
system-specific, although for obvious reasons both GASNet and the client 
code must agree on the threading system - unless otherwise noted, the 
default mechanism is POSIX threads.

@item GASNET_PARSYNC
Indicates a multi-threaded but non-concurrent (non-
threadsafe) GASNet environment, where multiple client threads may call 
GASNet, but their accesses to GASNet are fully serialized (e.g. by some 
level of synchronization above the GASNet interface). GASNet may safely 
assume that it will never be called from more than one client thread 
@emph{concurrently} (and the client must ensure this property holds). Client code 
must still use GASNet No-Interrupt Sections and Handler-Safe Locks to ensure 
correct operation.

@item GASNET_SEQ
Indicates a single-threaded, non-threadsafe environment. GASNet 
may safely assume that it will only ever be called from one unique client 
thread. Client code must still use GASNet No-Interrupt Sections and 
Handler-Safe Locks to ensure correct operation.
@end ftable

@IMPNOTE{
@item We may be able to make GASNet implementations independent of the 
threading system by having the client provide a few callback functions (e.g. 
mutex create/lock/unlock, thread create, threadid query and thread-local-
data set/get)
@item change the name of gasnet_init based on which mode is selected to ensure 
correct version is linked
@item An implementation of @code{GASNET_PAR} is sufficient to handle all the 
configurations - the other configurations just permit certain useful 
optimizations (such as removing unnecessary locking in the library)
@item Interrupt-driven implementations of @code{GASNET_SEQ} and @code{GASNET_PARSYNC} using 
signals must be prepared to handle the case where the thread responding to 
the signal may not be the thread currently inside a GASNet call. They may 
also need to use a private lock during HSL release to prevent multiple 
threads from polling simultaneously
}

@c ------------------------------------------------------------------------------------
@section Errors
@cindex Errors

Many GASNet core functions return 0 on success (@code{GASNET_OK}), or else they 
return errors from the following list, as specified by each function:
@ftable @code
@item GASNET_OK = 0 (no error)
@item GASNET_ERR_RESOURCE
@item GASNET_ERR_BAD_ARG
@item GASNET_ERR_NOT_INIT
@item GASNET_ERR_BARRIER_MISMATCH
@item GASNET_ERR_NOT_READY
@end ftable

Except where otherwise noted, errors that occur during a call to the 
extended API are fatal.

Many of the core API functions will return @code{GASNET_ERR_RESOURCE} to 
indicate a generic failure in the hardware or communications system, 
@code{GASNET_ERR_BAD_ARG} to indicate an illegal client argument, or 
@code{GASNET_ERR_NOT_INIT} to indicate that @code{gasnet_attach()} has not been called.

If any node of a GASNet job crashes, aborts, or suffers a fatal hardware 
error, GASNet should make every attempt to ensure that the remaining nodes 
of the job are terminated in a timely manner to prevent creation of orphaned 
processes. 

@c ------------------------------------------------------------------------------------
@section GASNet Types
@cindex Types

@table @code
@item gasnet_node_t
unsigned integer type representing a unique 0-based node index

@item gasnet_handle_t
an opaque type representing a non-blocking operation 
in-progress initiated using the extended API

@item gasnet_handler_t
an unsigned integer type representing an index into the core API AM handler table

@item gasnet_handlerarg_t
a 32-bit signed integer type which is used to express 
the user-provided arguments to all AM handlers. Platforms lacking a native 
32-bit type may define this to a 64-bit type, but only the lower 32-bits are 
transmitted during an AM message send (and sign-extended on the receiver).

@item gasnet_token_t
an opaque type passed to core API handlers which may be used to query message information 

@item gasnet_register_value_t
the largest unsigned integer type that can fit 
entirely in a single CPU register for the current architecture and ABI. 
@code{SIZEOF_GASNET_REGISTER_VALUE_T} is a preprocess-time literal integer constant 
(i.e. not @code{sizeof()})indicating the size of this type in bytes

@item gasnet_handlerentry_t
struct type used to negotiate handler registration 
in @code{gasnet_attach()}
@end table

@c ------------------------------------------------------------------------------------
@page
@section Compile-time constants

@ftable @code
@item GASNET_VERSION
an integer representing the major version of the GASNet spec to which this 
implementation complies. Implementations of this version of the 
specification should set this value to the integer 1

@item GASNET_MAXNODES
an integer representing the maximum number of nodes supported in a single 
GASNet job

@item GASNET_ALIGNED_SEGMENTS
defined by the GASNet implementation to the value 1 if @code{gasnet_attach()} 
guarantees that the remote-access memory segment will be aligned at the same virtual 
address on all nodes. Defined to 0 otherwise.
@end ftable

@c ------------------------------------------------------------------------------------
@section General notes

@itemize @bullet
@item All GASNet functions (in the extended @emph{and} core API) support loopback 
(i.e. a node sending a get or active message to itself), and all functions 
will still work in the case of single-node jobs (e.g. barriers are basically 
no-ops in that case)
@item GASNet will ensure that stdout/stderr are correctly propagated in a 
system-specific way (e.g. to the spawning console or possibly to a file or 
set of files). No guarantees are made about propagation of stdin, although 
some implementations may choose to deal with this.
@item GASNet makes no guarantees about the propagation of external signals 
across a job - however, see comments in @code{gasnet_exit}
@end itemize

@c ------------------------------------------------------------------------------------
@c ===========================================================================
@c                         ===== Core API ======
@c ===========================================================================
@HR
@node Core API
@chapter Core API
@cindex Core API

The core API consists of:
@itemize @bullet
@item A job control interface for bootstrapping, job termination and job 
environment queries
@item The active messaging interface for implementing requests, replies and 
handlers
@item An interface which provides handler signal-safety and atomicity control 
(No-Interrupt Sections and Handler-Safe Locks) 
@end itemize

@node Job Control Interface
@section Job Control Interface

Job startup in GASNet is a two-step process. GASNet programs should start by calling 
gasnet_init() as the first statement in their main() function, which bootstraps the nodes 
and establishes command-line arguments and the job environment. All nodes then call the
gasnet_attach() function to initialize the network and register shared memory segments.

GASNet initialization may register some UNIX signal handlers (e.g. to support 
interrupt-based implementations or aggressive segment registration policies). Client 
code which registers signal handlers must be careful not to preempt any 
GASNet-registered signal handlers (even for seemingly fatal signals such as 
@code{SIGABRT}) - the only signal which the client may always safely catch is 
@code{SIGQUIT}.

Any GASNet library implementation can be built in one of the following three 
configurations, which affects the behavior of remote-access memory segment registration
during gasnet_attach().
The @code{gasnet.h} header file will define the appropriate preprocessor symbol
to indicate which configuration is active.

@ftable @code
@item GASNET_SEGMENT_FAST
The remote-access memory segment is limited to an implementation-defined "reasonable" size,
and optimized in an implementation-specific way to provide the fastest possible 
remote accesses. The maximum segment size may be queried using
@code{gasnet_getMaxLocalSegmentSize()}.

@item GASNET_SEGMENT_LARGE
This configuration allows clients with larger shared data requirements to 
register a larger remote-access memory segment, possibly at some cost in the 
efficiency of remote accesses. The maximum segment size may be queried using
@code{gasnet_getMaxLocalSegmentSize()}, and should be comparable to the maximum
total data size allowed for processes on the given system.

@item GASNET_SEGMENT_EVERYTHING
The entire virtual memory space of each process is made available for remote access,
in a way such that any memory access that would succeed when executed locally by this node
would also succeed if executed by other nodes remotely. This can be used by clients which
need to make the entire memory heap and static data areas available for remote access.
@end ftable

@IMPNOTE{
@item The maximum segment size for @code{GASNET_SEGMENT_FAST} on many implementations 
is likely to to be limited by factors such as the amount of pinnable physical memory
currently available in the system, and the access range of the NIC hardware.
@item @code{GASNET_SEGMENT_EVERYTHING} support can trivially be provided by implementing all
the remote-access operations and long AM messages using core API medium messages, 
such that all data accesses are actually executed by the local host processor. 
However, implementors are encouraged to investigate higher-performance alternatives whenever possible.
@item On systems requiring pinned segments, @code{GASNET_SEGMENT_LARGE} can be implemented
using dynamic pinning schemes (possibly with caching to amortize rendezvous and 
pinning costs) or combinations of direct remote accesses and AM-based accesses.
}

@FN gasnet_init
@cindex startup
@deftypefn {} {int} gasnet_init (int *@var{argc}, char ***@var{argv})

Bootstraps a GASNet job and performs any system-specific setup required. 

Called by all GASNet-based applications upon startup to bootstrap the nodes,
before any other processing takes place. Must be called before 
any calls to any other functions in this specification, and before any 
investigation of the command-line parameters passed to the program in 
@var{argc}/@var{argv}, which may be modified or augmented by this call. 
The semantics of any code executing before the call to @code{gasnet_init()} 
is implementation-specific (for example, it is undefined whether 
@code{stdin/stdout/stderr} are functional, or even how many nodes will run that code).

Upon return from @code{gasnet_init()}, all the nodes of the job will be running,
stdout/stderr will be functional, and the basic job environment will be established, 
however the primary network resources may not yet have been initialized.
The following GASNet functions are the only ones that may be called between
@code{gasnet_init()} and @code{gasnet_attach()}:
@example
@code{gasnet_mynode()}
@code{gasnet_nodes()}
@code{gasnet_getMaxLocalSegmentSize()}
@code{gasnet_getMaxGlobalSegmentSize()}
@code{gasnet_getenv()}
@code{gasnet_exit()}
@end example
All other GASNet calls are prohibited until after a successful @code{gasnet_attach()}.

@code{gasnet_init()} may fail with a fatal error and implementation-defined message if 
the nodes of the job cannot be successfully bootstrapped. It also may return 
an error code such as @code{GASNET_ERR_RESOURCE} to indicate there was a problem 
acquiring network or system resources. Otherwise, it returns @code{GASNET_OK} to indicate success. 
May only be called once during a process lifetime, subsequent calls will 
return an error.

@end deftypefn

@FN gasnet_attach
@cindex segment
@cindex gasnet_handlerentry_t
@lisp
typedef struct @{
  gasnet_handler_t index; // == 0 for don't care 
  void (*fnptr)();
@} gasnet_handlerentry_t; 

@end lisp
@deftypefn {} {int} gasnet_attach (gasnet_handlerentry_t *@var{table}, int @var{numentries}, @w{uintptr_t @var{segsize}, uintptr_t @var{minheapoffset}})

Initializes the GASNet network system and performs any system-specific setup 
required. 

@var{table} is an array of @var{numentries} gasnet_handlerentry_t elements used for registering 
active-message handlers provided by the client code. Clients that never explicitly 
call the active-message request functions in the core API need not register 
any handlers, and may pass a @code{NULL} pointer for @var{table}. Clients wishing to 
register some handlers should fill in @var{table} with function pointers and 
the desired handler index (or index 0 for "don't-care") - note that handlers 
0..199 are reserved for GASNet internal use, and handlers 200..255 are 
available for client-provided handlers. Once @code{gasnet_attach()} returns, any 
"don't care" handler indexes in the table will be modified in place to 
reflect the handler index assigned for each handler - the assignment 
algorithm is deterministic: passing the same handler table on each node will 
guarantee an identical resulting assignment on each node. Handler function 
prototypes should match the prototypes described in the Active Message 
Interface section.

@var{segsize} and @var{minheapoffset} are used to communicate the desired size and  
location of the remote-access memory data segment for the local node that 
will be used for all remote accesses (i.e. using the data transfer functions 
of the extended API) or as the target of any Long active-messages in 
the core API. The client passes the desired size of this area in bytes as 
@var{segsize}, which must be a multiple of the system page size, and 
should be less than or equal to the value returned by @code{gasnet_getMaxLocalSegmentSize()}.
@var{minheapoffset} specifies the minimum amount of virtual memory space (in bytes)
to leave between the end of the current memory heap and the beginning of the 
remote-access memory segment (on some systems the size of this offset 
may limit the total future growth of the
local memory heap, on other systems it may be irrelevant). Note that specifying a large
@var{minheapoffset} may limit the possible size of the remote-access segment on some systems.
Passing a @var{segsize} of zero disables the remote-access segment for this node, meaning
other nodes cannot access it with remote-memory operations and this node 
cannot be the target of any Long AM messages.

GASNet will attempt to place the data segment in an area of the virtual memory space 
whose pages are currently unused (e.g. by calling @code{mmap}). 
The actual remote-access segment size achieved may be less than @var{segsize} if insufficient 
system resources are available - the exact size and location of the segment 
for all nodes should be queried after attach using @code{gasnet_getSegmentInfo()}. 
The segment assignment is guaranteed to have a page-aligned base address and size, 
but may differ in size across nodes, according to the requested segment sizes and 
system resource availability.
GASNet will not initialize data within the memory segment in any way, nor 
will it attempt to access the memory locations within the segment until 
directed to do so by a data transfer function or Long active message. 

If the GASNet implementation defines the macro @code{GASNET_ALIGNED_SEGMENTS} to 1, then 
@code{gasnet_attach()} guarantees that the remote-access memory segment will be 
aligned at the same virtual address across all nodes (and will fail if it cannot 
provide this). Otherwise, this guarantee is not provided. 

In the @code{GASNET_SEGMENT_FAST} and @code{GASNET_SEGMENT_LARGE}
configurations, GASNet guarantees that data transfer functions, 
Long active messages and local accesses referencing memory locations 
in the remote-access memory segment will succeed, even before any local activity 
takes place on those pages 
(i.e. in an implementation performing lazy registration, first touch = allocate). 

@var{segsize} and @var{minheapoffset} are ignored in the @code{GASNET_SEGMENT_EVERYTHING}
configuration, as the entire virtual memory space is implicitly shared for remote access.
Under this configuration, it is the client's responsibility to ensure that any 
remote-memory references fall within the legal areas of the current heap and data segment 
for the target node - 
remote accesses or Long active messages to locations outside these areas will have undefined effects
(for example, they @emph{may} cause a segmentation fault on the target node).

@code{gasnet_attach()} may fail with a fatal error and implementation-defined message if 
the network cannot be successfully initialized. It also may return 
an error code such as @code{GASNET_ERR_RESOURCE} to indicate there was a problem 
acquiring nework or system resources. Otherwise, it returns @code{GASNET_OK} to indicate success. 

A successful call acts as a global 
barrier and blocks until all other nodes which are part of this parallel job 
have successfully called @code{gasnet_attach()}.
May only be called once during a process lifetime, subsequent calls will 
return an error.
@end deftypefn

@IMPNOTE{
@item In the @code{GASNET_SEGMENT_FAST} and @code{GASNET_SEGMENT_LARGE}
configurations, GASNet must take steps to ensure the pages in the 
segment have been properly registered for remote access in a system-specific 
and implementation-specific way (e.g. mmapping them so they get added to the 
process page table, pinning the pages, registering the physical address with 
the NIC, etc.). Implementations are encouraged to defer consuming physical 
memory or swap space resources for pages in the segment until the first 
actual reference to them. 
@item Every implementation that pins pages needs a strategy for handling remote accesses 
under the @code{GASNET_SEGMENT_LARGE} and @code{GASNET_SEGMENT_EVERYTHING} configurations
when the segment size exceeds the amount of pinnable pages - e.g. some 
implementations may dynamically pin pages, others may pin only a portion of 
the segment and use an extra copy to handle access to data outside the 
pinned region.
@item Some GASNet implementations may need to allocate and pin additional memory 
for their own internal use in messaging (e.g. send buffers), but such memory 
should not fall within the client's data segment under @code{GASNET_SEGMENT_FAST} and @code{GASNET_SEGMENT_LARGE}
(although it may be adjacent to it).
@item Some GASNet implementations may also choose to pin other pages to optimize 
access and remove extra copies - for example, pinning the program stack may 
be advisable on some systems since a large number of the data transfer 
functions in the extended API are likely to use stack locations as the local 
source/destination.
}

@page
@FN gasnet_getMaxLocalSegmentSize
@cindex segment
@deftypefn {} {uintptr_t} gasnet_getMaxLocalSegmentSize ()

Retrieve an approximate, optimistic maximum size in bytes for the remote-access memory segment 
that may be provided to @code{gasnet_attach()} under the current configuration. 

The return value of this function may depend on 
current system resource usage, and may return different values on different nodes
of a job, according to current system utilization. The value returned will 
always be an even multiple of the system page size.

The value returned is an optimistic approximation of the segment size 
which can be acquired by @code{gasnet_attach()} - the actual size achieved can be queried 
after attach using @code{gasnet_getSegmentInfo()}.

On many implementations, this function will return different values in the 
@code{GASNET_SEGMENT_FAST} and @code{GASNET_SEGMENT_LARGE} configurations.
Under the @code{GASNET_SEGMENT_EVERYTHING} configuration, this function returns -1.

This function has undefined behavior after @code{gasnet_attach()}.
@end deftypefn

@FN gasnet_getMaxGlobalSegmentSize
@cindex segment
@deftypefn {} {uintptr_t} gasnet_getMaxGlobalSegmentSize ()

Returns a global minimum value
that would be returned by a call to @code{gasnet_getMaxLocalSegmentSize} 
on any node of the current job (i.e. the smallest max segment size 
estimated for any node in the job).

This function has undefined behavior after @code{gasnet_attach()}.
@end deftypefn

@FN gasnet_exit
@cindex exit
@deftypefn {} {void} gasnet_exit (int @var{exitcode})

Terminate the current GASNet job and return the given @var{exitcode} to the 
console which invoked the job (in a system-specific way). This call is @emph{not} 
a collective operation, meaning any node may call it at any time after 
initialization. It causes the system to flush all I/O, release all resources 
and terminate the job for all active nodes. If several nodes and/or threads 
call it simultaneously with different exit codes within a given 
synchronization phase, the result provided to the console will be one of the 
provided exit codes (chosen arbitrarily). This function should be called at 
the end of @code{main()} after a barrier to ensure proper system exit, and should 
also be called in the event of any fatal errors. GASNet clients are 
encouraged to call @code{gasnet_exit()} before explicitly exiting (by calling 
@code{exit(),} @code{abort()}) to reduce the possibility and lifetime of orphaned nodes, 
but this is not required. 

GASNet will send a @code{SIGQUIT} signal to the node if it detects that a remote 
node has called @code{gasnet_exit} or crashed (in which case the node should catch 
the signal, perform any system-specific shutdown, then call @code{gasnet_exit()} to 
end the local node process). GASNet will also send a @code{SIGQUIT} signal if it 
detects that the job has received a different catchable 
terminate-the-program signal (e.g. segmentation fault) since some of these other signals 
may be meaningful (and non-fatal) to certain GASNet implementations.
@end deftypefn

@c ------------------------------------------------------------------------------------
@node Job Environment Queries
@section Job Environment Queries

@FN gasnet_mynode
@deftypefn {} {gasnet_node_t} gasnet_mynode ()
 
returns the unique, 0-based node index representing this node in the current 
GASNet job
@end deftypefn

@FN gasnet_nodes
@deftypefn {} {gasnet_node_t} gasnet_nodes ()

returns the number of nodes in the current GASNet job
@end deftypefn

@FN gasnet_getSegmentInfo
@cindex segment
@cindex gasnet_seginfo_t
@lisp
typedef struct @{
  void *addr;
  uintptr_t size;
@} gasnet_seginfo_t;
@end lisp

@deftypefn {} {int} gasnet_getSegmentInfo (gasnet_seginfo_t *@var{seginfo_table}, int @var{numentries})

Query the segment base addresses and sizes for all the nodes in the job. 
@var{seginfo_table} is an array of @code{gasnet_seginfo_t} 
(and @var{numentries} is the number of entries in the table). 
The value of @var{numentries} should be at least @code{gasnet_nodes()}.
GASNet fills in the table with the remote-access segment base address and size 
in bytes for each node (including the local one).
This is a non-collective operation.
Returns @code{GASNET_OK} on success.

Note that when GASNET_ALIGNED_SEGMENTS=1, the base addresses are guaranteed to be
equal (i.e. all remote-access segments start at the same virtual addresses). 
However, in any case
the segment sizes may differ across nodes, and specifically they may differ from the 
size requested by the client in the @code{gasnet_attach()} size hint.
@end deftypefn

@FN gasnet_getenv
@cindex environment variables
@deftypefn {} {char *} gasnet_getenv (const char *@var{name})

Has the same semantics as the POSIX @code{getenv()} call, except it queries the 
system-specific environment which was used to spawn the job (e.g. the 
environment of the spawning console). Calling POSIX @code{getenv()} directly on 
some implementations may not correctly return values reflecting the 
environment that initiated the job spawn, consequently GASNet applications
should never call @code{getenv()} directly. The semantics of POSIX @code{setenv()} 
are undefined in GASNet jobs (specifically, it will probably fail to 
propagate changes across nodes). 
@end deftypefn

@c ------------------------------------------------------------------------------------
@node Active Messaging Interface
@section Active Messaging Interface

Active message communication is formulated as logically matching request and 
reply operations. Upon receipt of a request message, a request handler is 
invoked; likewise, when a reply message is received, the reply handler is 
invoked. Request handlers can reply at most once to the requesting node. If 
no explicit reply is made, the layer may generate one (to an implicit 
do-nothing reply handler). Thus a request handler can call reply at most once, 
and may only reply to the requesting node. Reply handlers cannot request or reply. 

Here is a high-level description of a typical active message exchange 
between two nodes, A and B:

@enumerate
@item
A calls @code{gasnet_AMRequest*()} to send a request to B. 
The call includes arguments, data payload, the node index of B and the index of 
the request handler to run on B when the request arrives                           
                                                                                
@item
At some later time, B receives the request, and runs the appropriate 
request handler with the arguments and data (if any) provided in the 
@code{gasnet_AMRequest*()} call.
  The request handler does some work on the arguments, and usually finishes 
by calling @code{gasnet_AMReply*()} to issue a reply message before it exits (replying is 
optional in GASNet, but required in AM2 - if the request handler does not 
reply then no further actions are taken).                                                               
  @code{gasnet_AMReply*()} takes the token passed to the request handler, arguments and data 
payload, and the index of the reply handler to run when the reply message 
arrives. It does not take a node index because a request handler is only 
permitted to send a reply to the requesting node                           
                                                                                
@item
At some later time, A receives the reply message from B and runs the 
appropriate reply handler, with the arguments and data (if any) provided in 
the @code{gasnet_AMReply*()} call. 
  The reply handler does some work on the arguments and then exits. It is 
not permitted to send further messages.                   
@end enumerate

The message layer will deliver requests and replies to destination nodes 
barring any catastrophic errors (e.g. node crashes). From a sender's point 
of view, the request and reply functions block until the message is sent. A 
message is defined to be sent once it is safe for the caller to reuse the storage 
(registers or memory) containing the message (one notable exception to this 
policy is @code{gasnet_RequestLargeAsyncM()}). In implementations which copy or 
buffer messages for transmission, the definition still holds: message sent 
means the layer has copied the message and promises to deliver the copy with 
its "best effort", and the original message storage may be reused. By best 
effort, the message layer promises it will take care of all the details 
necessary to transmit the message. These details include any retransmission 
attempts and buffering issues on unreliable networks. 

However, in either case, sent does not imply received. Once control returns 
from a request or reply function, clients cannot assume that the message has 
been received and handled at the destination. The message layer only 
guarantees that if a request or reply is sent, and, if the receiver 
occasionally polls for arriving messages, then the message will eventually 
be received and handled. From a receiver's point of view, a message is 
defined to be received only once its handler function is invoked. The 
contents of partially received messages and messages whose handlers have not 
executed are undefined. 

If the client sends an AM request or AM reply to a handler index which has
not been registered on the destination node, GASNet will print an implementation-defined
error message and terminate the job. It is implementation-defined whether this
checking happens on the sending or receiving node.

@c ------------------------------------------------------------------------------------
@node Active Message Categories
@subsection Active Message Categories

There are 3 categories of active messages:

@table @samp
@cindex Short Active Message
@item Short Active Message
These messages carry only a few integer arguments (up to @code{gasnet_AMMaxShort()})
@*handler prototype: 
@lisp
void handler(gasnet_token_t token, 
             gasnet_handlerarg_t arg0, ... gasnet_handlerarg_t argM-1);
@end lisp
@cindex Medium Active Message
@item Medium Active Message
In addition to integer arguments, these messages can can carry an opaque 
data payload (up to @code{gasnet_AMMaxMedium()} bytes in length), that will
be made available to the handler when it is run on the remote node.
@*handler prototype: 
@lisp
void handler(gasnet_token_t token, 
             void *buf, size_t nbytes,
             gasnet_handlerarg_t arg0, ... gasnet_handlerarg_t argM-1);
@end lisp
@cindex Long Active Message
@item Long Active Message
In addition to integer arguments, these messages can carry an opaque 
data payload (up to @code{gasnet_AMMaxLong()} bytes in length) which is destined 
for a particular predetermined address in the segment of the remote node 
(often implemented using RDMA hardware assistance)
@*handler prototype: 
@lisp
void handler(gasnet_token_t token, 
             void *buf, size_t nbytes,
             gasnet_handlerarg_t arg0, ... gasnet_handlerarg_t argM-1);
@end lisp
@end table

The number of handler arguments (M) is specified upon issuing a request or 
reply by choosing the request/reply function of the appropriate name. The 
category of message and value of M used in the request/reply message sends 
determines the appropriate handler prototype, as detailed above. If a 
request or reply is sent to a handler whose prototype does not match the 
requirements as detailed above, the result is undefined.

@IMPNOTE{
@item Some implementations may choose to optimize medium and long messages for 
payloads whose base address and length are aligned with certain convenient 
sizes (word-aligned, doubleword-aligned, page-aligned etc.) but this does 
not affect correctness.
}

@c ------------------------------------------------------------------------------------
@node Active Message Size Limits
@subsection Active Message Size Limits
@cindex Message size

These functions are used to query the maximum size messages of each category supported by a 
given implementation. These are likely to be implemented as macros for 
efficiency of client code which uses them (within packing loops, etc.)

@FN gasnet_AMMaxArgs
@deftypefn {} {size_t} gasnet_AMMaxArgs ()

Returns the maximum number of handler arguments (i.e. M) that may be passed 
with any AM request or reply function. This value is guaranteed to be at 
least @code{(2 * MAX(sizeof(int),sizeof(void*)))} (i.e. 8 for 32-bit systems, 16 
for 64-bit systems), which ensures that 8 ints and/or pointers can be sent 
with any active message. All implementations must support @emph{all} values of M 
from 0...@code{gasnet_AMMaxArgs()}.
@end deftypefn

@FN gasnet_AMMaxMedium
@deftypefn {} {size_t} gasnet_AMMaxMedium ()

Returns the maximum number of bytes that can be sent in the payload of a 
single medium AM request or reply. This value is guaranteed to be at least 
512 bytes on any implementation.
@end deftypefn

@FN gasnet_AMMaxLongRequest
@deftypefn {} {size_t} gasnet_AMMaxLongRequest ()

Returns the maximum number of bytes that can be sent in the payload of a 
single long AM request. This value is guaranteed to be at least 512 bytes on 
any implementation. Implementations which use RDMA to implement long 
messages are likely to support a much larger value.
@end deftypefn

@FN gasnet_AMMaxLongReply
@deftypefn {} {size_t} gasnet_AMMaxLongReply ()

Returns the maximum number of bytes that can be sent in the payload of a 
single long AM reply. This value is guaranteed to be at least 512 bytes on 
any implementation. Implementations which use RDMA to implement long 
messages are likely to support a much larger value.
@end deftypefn


@c ------------------------------------------------------------------------------------
@node Active Message Request Functions
@subsection Active Message Request Functions
@cindex Requests

In the function descriptions below, M is to be replaced with a number in [0 ... @code{gasnet_AMMaxArgs()}]

@FN gasnet_AMRequestShortM
@deftypefn {} {int} gasnet_AMRequestShortM ( gasnet_node_t @var{dest}, gasnet_handler_t @var{handler}, gasnet_handlerarg_t @var{arg0}, ..., gasnet_handlerarg_t @var{argM-1} ); 

Send a short AM request to node @var{dest}, 
to run the handler registered on the destination node at handler table index @var{handler}, 
with the given M arguments. 
@code{gasnet_AMRequestShortM} returns control to the calling thread of computation 
after sending the request message. Upon receipt, the receiver invokes the 
appropriate active message request handler function with the M integer 
arguments. 
Returns @code{GASNET_OK} on success.
@end deftypefn

@FN gasnet_AMRequestMediumM
@deftypefn {} {int} gasnet_AMRequestMediumM ( gasnet_node_t @var{dest}, gasnet_handler_t @var{handler}, @w{void *}@var{source_addr}, size_t @var{nbytes}, gasnet_handlerarg_t @var{arg0}, ..., @w{gasnet_handlerarg_t @var{argM-1}} )

Send a medium AM request to node @var{dest}, 
to run the handler registered on the destination node at handler table index @var{handler}, 
with the given M arguments. 

The message also carries a data payload copied from the local node's memory 
space as indicated by @var{source_addr} and @var{nbytes}
(which need not fall within the registered data segment on the local node). 
The value of @var{nbytes} must be no larger than the value returned by 
@code{gasnet_AMMaxMedium()}.

@code{gasnet_AMRequestMediumM} returns control to the calling thread of computation 
after sending the associated request, and the source memory may be freely 
modified once the function returns. The active message is logically 
delivered after the data transfer finishes. 

Upon receipt, the receiver invokes the appropriate request handler function 
with a pointer to temporary storage containing the data payload, the number 
of data bytes transferred, and the M integer arguments. The dynamic scope of 
the storage is the same as the dynamic scope of the handler. The data should 
be copied if it is needed beyond this scope. 
Returns @code{GASNET_OK} on success.
@end deftypefn

@FN gasnet_AMRequestLongM
@deftypefn {} {int} gasnet_AMRequestLongM ( gasnet_node_t @var{dest}, gasnet_handler_t @var{handler}, @w{void *}@var{source_addr}, size_t @var{nbytes}, void *@var{dest_addr}, gasnet_handlerarg_t @var{arg0}, ..., gasnet_handlerarg_t @var{argM-1} ); 

Send a long AM request to node @var{dest}, 
to run the handler registered on the destination node at handler table index @var{handler}, 
with the given M arguments. 

The message also carries a data payload copied from the local node's memory 
space as indicated by @var{source_addr} and @var{nbytes}
(which need not fall within the registered data segment on the local node). 
The value of nbytes must be no larger than the value returned by 
@code{gasnet_AMMaxLongRequest()}.
The memory specified by [@var{dest_addr}...(@var{dest_addr}+@var{nbytes}-1)] must fall 
entirely within the memory segment registered for remote access by the 
destination node. This area will receive the data transfer before the handler runs.

If @var{dest} is the current node (i.e. loopback) and the source and destination 
memory overlap, the result is undefined.
@code{gasnet_AMRequestLongM} returns control to the calling thread of computation 
after sending the associated request, and the source memory may be freely 
modified once the function returns. The active message is logically 
delivered after the bulk transfer finishes. Upon receipt, the receiver 
invokes the appropriate request handler function with a pointer into the 
memory segment where the data was placed, the number of data bytes 
transferred, and the M integer arguments. 
Returns @code{GASNET_OK} on success.
@end deftypefn

@FN gasnet_AMRequestLongAsyncM
@deftypefn {} {int} gasnet_AMRequestLongAsyncM ( gasnet_node_t @var{dest}, gasnet_handler_t @var{handler}, @w{void *}@var{source_addr}, size_t @var{nbytes}, void *@var{dest_addr}, gasnet_handlerarg_t @var{arg0}, ..., gasnet_handlerarg_t @var{argM-1} ); 

@code{gasnet_AMRequestLongAsyncM()} has identical semantics to 
@code{gasnet_AMRequestLongM()}, except that the data payload source memory must NOT 
be modified until the matching reply handler has executed. 
Some implementations may leverage this additional constraint to provide 
higher performance (e.g. by reducing extra data copying).
@end deftypefn

@IMPNOTE{
@item Note that unlike the AM2.0 function of similar name, this function is permitted to block 
temporarily if the network is unable to immediately accept the new request.
}

@c ------------------------------------------------------------------------------------
@node Active Message Reply Functions
@subsection Active Message Reply Functions
@cindex Replies

The following active message reply functions may only be called from the context of a
running active message request handler, and a reply function may be called at most once from any
given request handler (it is an error to do otherwise).

@FN gasnet_AMReplyShortM
@deftypefn {} {int} gasnet_AMReplyShortM ( gasnet_token_t @var{token}, gasnet_handler_t @var{handler}, gasnet_handlerarg_t @var{arg0}, ..., gasnet_handlerarg_t @var{argM-1} ); 

Send a short AM reply to the indicated @var{handler} on the requesting node (i.e. the 
node responsible for this particular invocation of the request handler), and 
include the given M arguments. 
@code{gasnet_AMReplyShortM} returns control to the calling thread of computation 
after sending the reply message. 

Upon receipt, the receiver invokes the appropriate active message reply 
handler function with the M integer arguments. 
Returns @code{GASNET_OK} on success.
@end deftypefn

@FN gasnet_AMReplyMediumM
@deftypefn {} {int} gasnet_AMReplyMediumM ( gasnet_token_t @var{token}, gasnet_handler_t @var{handler}, @w{void *@var{source_addr}}, size_t @var{nbytes}, gasnet_handlerarg_t @var{arg0}, ..., @w{gasnet_handlerarg_t @var{argM-1}} ); 

Send a medium AM reply to the indicated @var{handler} on the requesting node (i.e. the 
node responsible for this particular invocation of the request handler), with 
the given M arguments and given data payload copied from the local node's 
memory space (@var{source_addr} need not fall within the registered data segment 
on the local node). 
The value of @var{nbytes} must be no larger than the value returned by 
@code{gasnet_AMMaxMedium()}.
@code{gasnet_AMReplyMediumM} returns control to the calling thread of computation 
after sending the associated reply, and the source memory may be freely 
modified once the function returns. The active message is logically 
delivered after the data transfer finishes. 

Upon receipt, the receiver invokes the appropriate reply handler function 
with a pointer to temporary storage containing the data payload, the number 
of data bytes transferred, and the M integer arguments. The dynamic scope of 
the storage is the same as the dynamic scope of the handler. The data should 
be copied if it is needed beyond this scope. 
Returns @code{GASNET_OK} on success.
@end deftypefn

@FN gasnet_AMReplyLongM
@deftypefn {} {int} gasnet_AMReplyLongM ( gasnet_token_t @var{token}, gasnet_handler_t @var{handler}, @w{void *}@var{source_addr}, size_t @var{nbytes}, void *@var{dest_addr}, gasnet_handlerarg_t @var{arg0}, ..., gasnet_handlerarg_t @var{argM-1} ); 

Send a long AM reply to the indicated @var{handler} on the requesting node (i.e. the 
node responsible for this particular invocation of the request handler), with 
the given M arguments and given data payload copied from the local node's 
memory space (@var{source_addr} need not fall within the registered data segment 
on the local node). 
The value of @var{nbytes} must be no larger than the value returned by 
@code{gasnet_AMMaxLongReply()}.
The memory specified by [@var{dest_addr}...(@var{dest_addr}+@var{nbytes}-1)] must fall 
entirely within the memory segment registered for remote access by the 
destination node.
If dest is the current node (i.e. loopback) and the source and destination 
memory overlap, the result is undefined.
@code{gasnet_AMReplyLongM} returns control to the calling thread of computation 
after sending the associated reply, and the source memory may be freely 
modified once the function returns. The active message is logically 
delivered after the bulk transfer finishes. 

Upon receipt, the receiver 
invokes the appropriate reply handler function with a pointer into the 
memory segment where the data was placed, the number of data bytes 
transferred, and the M integer arguments. 
Returns @code{GASNET_OK} on success.
@end deftypefn

@c ------------------------------------------------------------------------------------
@node Misc. Active Message Functions
@subsection Misc. Active Message Functions
@cindex Poll

@FN gasnet_AMPoll
@deftypefn {} {int} gasnet_AMPoll ()

An explicit call to service the network, process pending messages and run 
handlers as appropriate.
Most of the message-sending primitives in GASNet poll the network 
implicitly.
Purely polling-based implementations of GASNet may require occasional calls 
to this function to ensure progress of remote nodes during compute-only 
loops. Any client code which spin-waits for the arrival of a message should 
call this function within the spin loop to optimize response time.
This call may be a no-op on some implementations (e.g. purely interrupt-based 
implementations).
Returns @code{GASNET_OK} unless an error condition was detected.
@end deftypefn

@FN GASNET_BLOCKUNTIL
@code{#define GASNET_BLOCKUNTIL(cond) ???}

This is a macro which implements a busy-wait/blocking polling loop in the 
way most efficient for the current GASNet core implementation. The macro 
blocks execution of the current thread and services the network until the 
provided condition becomes true. @var{cond} is an arbitrary C expression which 
will be evaluated by the macro one or more times as active messages arrive 
until the condition evaluates to a non-zero value. @var{cond} is an expression 
whose value is altered by the execution of an AM handler which the client 
thread is waiting for - GASNet may safely assume that the value of @var{cond} will 
only change while an AM handler is executing. 

Example usage:
@lisp
 int doneflag = 0;
 gasnet_AMRequestShort1(..., &doneflag); // reply handler sets doneflag to 1
 GASNET_BLOCKUNTIL(doneflag == 1);
@end lisp

Note that code like this would be illegal and could cause node 0 to sleep 
forever:
@lisp
 static int doneflag = 0;
 node 0:                                 node 1:
 GASNET_BLOCKUNTIL(doneflag == 1);       gasnet_put_val(0, &doneflag, 1, sizeof(int));
@end lisp
because @code{gasnet_put_val} (and other extended API functions) might not be 
implemented using AM handlers.

@IMPNOTE{
@item one trivial implementation:  
@code{#define GASNET_BLOCKUNTIL(cond) while (!(cond)) gasnet_AMPoll()}
@item smarter implementations may choose to spin for awhile and then block 
@item Any implementation that includes blocking must ensure progress if all 
client threads call GASNET_BLOCKUNTIL(), and must ensure the blocked thread 
is awakened even if the handler is run synchronously during a 
@code{gasnet_AMPoll()} call from a different client thread. Other client threads 
performing sends or polls must not be prevented from making progress by the 
blocking thread (possibly a motivation @emph{against} the "trivial 
implementation" above).
}

@FN gasnet_AMGetMsgSource
@deftypefn {} {int} gasnet_AMGetMsgSource (gasnet_token_t @var{token}, gasnet_node_t *@var{srcindex})

Can be called by handlers to query the source of the message being handled. 
The @var{token} argument must be the token passed into the handler on entry. 
Returns @code{GASNET_OK} on success.
@end deftypefn


@c ------------------------------------------------------------------------------------
@node Atomicity Control
@section Atomicity Control
@cindex Atomicity

@node Atomicity semantics of handlers
@subsection Atomicity semantics of handlers

Handlers may run asynchronously with respect to the main computation (in an 
implementation which uses interrupts to run some or all handlers), and they 
may run concurrently with each other on separate threads (e.g. in a CLUMP 
implementation where several threads may be polling the network at once). An 
implementation using interrupts may result in handler code running within a 
signal handler context. Some implementations may even choose to run handlers 
on a separate private thread created by GASNet (making handlers asynchronous 
with respect to all client threads). Note that polling-based GASNet 
implementations are likely to poll (and possibly run handlers) from within 
@emph{any} GASNet call (i.e. not just @code{gasnet_AMPoll()}). Because of all this, 
handler code should run quickly and to completion without making blocking 
calls, and should not make assumptions about the context in which it is 
being run (special care must be taken to ensure safety in a signal handler 
context, see below).

Regardless, handlers themselves are not interruptible - any given thread 
will only be running a single AM handler at a time and will never be 
interrupted to run another AM handler (there is one exception to this rule - 
the @code{gasnet_AMReply*()} call in a request handler may cause reply handlers to 
run synchronously, which may be necessary to avoid deadlock in some 
implementations. This should not be a problem since @code{gasnet_AMReply*()} is 
often the last action taken by a request handler).  Handlers are 
specifically prohibited from initiating random network communication to 
prevent deadlock - request handlers must generate at most one reply (to the 
requestor) and make no other communication calls (including polling), and 
reply handlers may not communicate or poll at all.

The asynchronous nature of handlers requires two mechanisms to make them 
safe: a mechanism to ensure signal safety for GASNet implementations using 
interrupt-based mechanisms, and a locking mechanism to allow atomic updates 
from handlers to data structures shared with the client threads and other 
handlers.

(see @uref{http://www.cs.berkeley.edu/~bonachea/upc/} for a more 
detailed discussion on handler atomicity)

@c ------------------------------------------------------------------------------------
@node No-Interrupt Sections
@subsection No-Interrupt Sections - Ensuring signal-safety for handlers 

Traditionally, code running in signal handler context is extremely 
circumscribed in what it can do: e.g. none of the standard pthreads/System V 
synchronization calls are on the list of signal-safe functions (for such a 
list see @cite{Richard Stevens' "Advanced Programming in the Unix Environment", p 278}). 
Note that even most "thread-safe" libraries will break or deadlock if 
called from a signal handler by the same thread currently executing a 
different call to that library in an earlier stack frame. One specific case 
where this is likely to arise in practice is calls to @code{malloc()}/@code{free()}. To 
overcome these limitations, and allow our handlers to be more useful, the 
normal limitations on signal handlers will be avoided by allowing the client 
thread to temporarily disable the network interrupts that run handlers. All 
function calls that are not signal-safe and could possibly access state 
shared by functions also called from handlers MUST be called within a GASNet 
"No-Interrupt Section": 

@FNH gasnet_hold_interrupts, gasnet_resume_interrupts
@FNI gasnet_hold_interrupts
@FNI gasnet_resume_interrupts
@deftypefn {} {void} gasnet_hold_interrupts ()
@deftypefnx {} {void} gasnet_resume_interrupts ()

@code{gasnet_hold_interrupts()} and @code{gasnet_resume_interrupts()} are used to define a 
GASNet No-Interrupt Section (any code which dynamically executes between the 
hold and resume calls is said to be "inside" the No-Interrupt Section).
These are likely to be implemented as macros and highly tuned for 
efficiency.
The hold and resume calls must be paired, and may @emph{not} be nested 
recursively or the results are undefined (this means that clients should be 
especially careful when calling other functions in the client from within a 
No-Interrupt Section).
Both calls will return immediately in the common case, although one or both 
may cause messages to be serviced on some implementations.
GASNet guarantees that no handlers will run asynchronously 
@strong{on the current thread} within the No-Interrupt Section. 
The no-interrupt state is a 
per-thread setting, and GASNet may continue running handlers synchronously or 
asynchronously on other client threads or GASNet-private threads (even in a 
@code{GASNET_SEQ} configuration) - specifically, a No-Interrupt Section does @strong{not} 
guarantee atomicity with respect to handler code, it merely provides a way 
to ensure that handlers won't run on a given thread while it's inside a call 
to a non-signal-safe library.
@end deftypefn

@c ------------------------------------------------------------------------------------
@node Restrictions on No-Interrupt Sections
@subsection Restrictions on No-Interrupt Sections

There is a strict set of conventions governing the use of 
No-Interrupt Sections which must be followed in order to ensure correct operation on all 
GASNet implementations. Clients which violate any of these rules may be 
subject to intermittent crashes, fatal errors or network deadlocks.

@itemize @bullet
@item @code{gasnet_hold_interrupts()} and @code{gasnet_resume_interrupts()} should not be 
called from within a handler context - handlers are run within an implicit 
No-Interrupt Section

@item Code in a No-Interrupt Section must not call any GASNet functions that may 
send requests or synchronously run handlers - specifically, the only GASNet 
functions which may legally by called within the No-Interrupt Section are:
@example
@code{gasnet_mynode()}, @code{gasnet_nodes()}, @code{gasnet_hsl_*()}, @code{gasnet_exit()}, @code{gasnet_AMReply*()}
@end example
Note that due to the previous rule, these are also the only GASNet functions 
that may legally be called within a handler context (and @code{gasnet_AMReply*()} 
is only legal in a request handler).

@item Code in a No-Interrupt Section must never block or spin-wait for an 
unbounded amount of time, especially when awaiting a result produced by a 
handler

@item No-Interrupt Sections should only be held "briefly" to avoid starving the 
network (could cause performance degradation, but should not affect 
correctness). Very long No-Interrupt Sections (i.e. on the order of 10 sec 
or more) could cause some GASNet implementations employing timeout-based 
mechanisms to fail (e.g. remote nodes may decide this node is dead and abort 
the job).
@end itemize

@IMPNOTE{
@item One possible implementation:
Keep a bit for each thread indicating whether or not a No-Interrupt Section 
is in effect, which is checked by all asynchronous signal handlers.
If a signal arrives while a No-Interrupt Section is in effect, a different 
per-thread bit in memory will be marked indicating a "missed GASNet signal": 
the @code{gasnet_resume_interrupts()} call will check this bit, and if it is set, 
the action for the signal will be taken (the action for a GASNet signal is 
always to check the queue of incoming network messages, so there's no 
ambiguity on what the signal meant. Since messages are queued, the single 
'signal missed' bit is sufficient for an arbitrary number of missed signals 
during a single No-Interrupt Section - GASNet messages will be removed and 
processed until the queue is empty). 
@item Implementation needs to hold a No-Interrupt Section over a thread while 
running handlers
@item Strictly polling-based implementations which never interrupt a thread can 
implement these as a no-op.
}

@c ------------------------------------------------------------------------------------
@node Handler-Safe Locks
@subsection Handler-Safe Locks
@cindex Locks

In order to support handlers atomically updating data structures accessed by 
the main-line client code and other handlers, GASNet provides the 
Handler-Safe Lock (HSL) mechanism. As the name implies, these are a special kind of 
lock which are distinguished as being the @strong{only} type of lock which may be 
safely acquired from a handler context. There is also a set of restrictions 
on their usage which allows this to be safe (see below). All lock-protected 
data structures in the client that need to be accessed by handlers should be 
protected using a Handler-Safe Lock (i.e. instead of a standard POSIX 
mutex). 

@FN gasnet_hsl_t
@code{gasnet_hsl_t} is an opaque type representing a Handler-Safe Lock. 
HSL's operate analogously to POSIX mutexes, in that they are always 
manipulated using a pointer.

@FNH gasnet_hsl_init, gasnet_hsl_destroy
@FNI gasnet_hsl_init
@FNI gasnet_hsl_destroy
@findex GASNET_HSL_INITIALIZER
@code{gasnet_hsl_t hsl = GASNET_HSL_INITIALIZER;}
@deftypefn {} {void} gasnet_hsl_init   (gasnet_hsl_t *@var{hsl})
@deftypefnx {} {void} gasnet_hsl_destroy (gasnet_hsl_t *@var{hsl})

Similarly to POSIX mutexes, HSL's can be created in two ways. They can be 
statically declared and initialized using the @code{GASNET_HSL_INITIALIZER} 
constant. Alternately, HSL's allocated using other means (such as dynamic 
allocation) may be initialized by calling @code{gasnet_hsl_init()}. 
@code{gasnet_hsl_destroy()} may be called on either type of HSL once it's no longer 
needed to release any system resources associated with it. 
It is erroneous to call @code{gasnet_hsl_init()} on a given HSL more than once. It 
is erroneous to destroy an HSL which is currently locked. Any errors 
detected in HSL initialization/destruction are fatal.
@end deftypefn

@FNH gasnet_hsl_lock, gasnet_hsl_unlock
@FNI gasnet_hsl_lock
@FNI gasnet_hsl_unlock
@deftypefn {} {void} gasnet_hsl_lock   (gasnet_hsl_t *@var{hsl})
@deftypefnx {} {void} gasnet_hsl_unlock (gasnet_hsl_t *@var{hsl})

Lock and unlock HSL's. @code{gasnet_hsl_lock()} will block until the @var{hsl} lock can be 
acquired by the current thread. @code{gasnet_hsl_lock()} may be called from within 
main-line client code or from within handlers - this is the @strong{only} blocking 
call which is permitted to execute within a GASNet handler context (e.g. it 
is erroneous to call POSIX mutex locking functions). 
@code{gasnet_hsl_unlock()} releases the @var{hsl} lock previously acquired using 
@code{gasnet_hsl_lock()}.
It is erroneous to call these functions on HSL's which have not been 
properly initialized.
Note that under the @code{GASNET_SEQ} configuration, HSL locking functions may only 
be called from handlers and the designated GASNet client thread (@emph{not} from 
other client threads that may happen to exist - those threads are not 
permitted to make @emph{any} GASNet calls, which includes HSL locking calls).
@end deftypefn

@c ------------------------------------------------------------------------------------
@node Restrictions on Handler-Safe Locks
@subsection Restrictions on Handler-Safe Locks

There is a strict set of conventions governing the use of HSL's which must 
be followed in order to ensure correct operation on all GASNet 
implementations. Amongst other things, the restrictions are designed to 
ensure that HSL's are always held for a strictly bounded amount of time, to 
ensure that acquiring them from within a handler can't lead to deadlock. 
Clients which violate any of these rules may be subject to intermittent 
crashes, fatal errors or network deadlocks. 

@itemize @bullet
@item Code executing on a thread holding an HSL is implicitly within a 
No-Interrupt Section, and must follow all the restrictions on code within a 
No-Interrupt Section (@pxref{Restrictions on No-Interrupt Sections}). @code{gasnet_hold_interrupts()} and 
@code{gasnet_resume_interrupts()} must not be explicitly called while holding an HSL

@item Any handler which locks one or more HSL's @strong{must} unlock them all before 
exiting or calling @code{gasnet_AMReply*()}

@item HSL's may @strong{not} be locked recursively (i.e. calling @code{gasnet_hsl_lock()} on a 
lock already held by the current thread) and attempting to do so will lead 
to undefined behavior. It @strong{is} permitted for a thread to acquire more than 
one HSL, although the traditional cautions about the possibility of deadlock 
in the presence of multiple locks apply (e.g. the common solution is to 
define a total order on locks and always acquire them in a monotonically 
ascending sequence).

@item HSL's must be unlocked in the reverse order they were locked (e.g. lock A; 
lock B; ... unlock B; unlock A; is legal - reversing the order of unlocks is 
erroneous)

@item HSL's may not be shared across GASNet processes executing on a machine - 
for example, it is specifically disallowed to place an HSL in a system V or 
mmapped shared memory segment and attempt to access it from two different 
GASNet processes.
@end itemize

@IMPNOTE{
@item HSL's are likely to just be a thin wrapper around a POSIX mutex - need to 
add just enough state/code to ensure the safety properties (must be a real 
lock, even under @code{GASNET_PARSYNC} because client may still have multiple threads).
The only specific action required is that a No-Interrupt Section is enforced 
while the main-line code is holding an HSL (must be careful this works 
properly when multiple HSL's are held or when running in a handler).
@item Robust implementations may add extra error checking to help discover 
violations of the restrictions, at least when compiled in a debugging mode - 
for example, it should be easy to detect: attempts at recursive locking on 
HSL's, incorrectly ordered unlocks, handlers that fail to release HSL's, 
explicit calls to @code{gasnet_hold_interrupts()} and @code{gasnet_resume_interrupts()} in 
a handler or while an HSL is held or in a No-Interrupt Section, and illegal 
calls to GASNet messaging functions while holding an HSL or inside a 
No-Interrupt Section.
}

@c ------------------------------------------------------------------------------------
@c ===========================================================================
@c                         ===== Extended API ======
@c ===========================================================================
@HR
@node Extended API
@chapter Extended API
@cindex Extended API
Errors in calls to the extended API are considered fatal and abort the job 
(by sending a @code{SIGABORT} signal) after printing an appropriate error message.

@node Memory-to-memory Data Transfer Functions
@section Memory-to-memory Data Transfer Functions
@cindex Data transfer semantics

These comments apply to all put/get functions:

@itemize @bullet
@item 
The @var{nbytes} parameter should be a compile-time constant whenever possible (for 
efficiency)

@item 
The source memory address for all gets and the target memory address for 
all puts must fall within the memory area registered for remote access by 
the remote node (see @code{gasnet_attach()}), or the results are undefined

@item 
Pointers to remote memory are passed as an ordered pair of arguments: an 
integer node rank (a @code{gasnet_node_t}) and a @code{void *} virtual memory address, 
which logically represent a global pointer to the given address on the given 
node. These global pointers need not be remote - the node rank passed to 
these functions may in fact be the rank of the current node - 
implementations must support this form of loopback, and should probably 
attempt to optimize it by avoiding network traffic for such purely local 
operations.

@item 
If the source memory and destination memory regions overlap (but do not 
exactly coincide) the resulting value is undefined
@end itemize

@c ------------------------------------------------------------------------------------
@node Blocking memory-to-memory Transfers
@section Blocking memory-to-memory Transfers
@cindex gets
@cindex puts

@FNH gasnet_get, gasnet_put
@FNI gasnet_get
@FNI gasnet_put
@deftypefn {} {void}   gasnet_get (void *@var{dest}, gasnet_node_t @var{node}, void *@var{src}, size_t @var{nbytes}) 
@deftypefnx {} {void}   gasnet_put (gasnet_node_t @var{node}, void *@var{dest}, void *@var{src}, size_t @var{nbytes}) 

Blocking get/put operations for aligned data. The get operation fetches 
@var{nbytes} bytes from the address @var{src} on node @var{node} and places them at 
@var{dest} in the local memory space. The put operation sends @var{nbytes} bytes 
from the address @var{src} in the local address space, and places them at the 
address @var{dest} in the memory space of node @var{node}. A call to these functions 
blocks until the transfer is complete, and the contents of the destination 
memory are undefined until it completes. If the contents of the source 
memory change while the operation is in progress the result will be 
implementation-specific. The @var{src} and @var{dest} addresses (whether local or 
remote) must be properly aligned for accessing objects of size @var{nbytes}. 
@var{nbytes} must be >= 0 and has no maximum size, but implementations will likely 
optimize for small powers of 2.
@end deftypefn

@FNH gasnet_get_bulk, gasnet_put_bulk
@FNI gasnet_get_bulk
@FNI gasnet_put_bulk
@deftypefn {} {void}   gasnet_get_bulk (void *@var{dest}, gasnet_node_t @var{node}, void *@var{src}, size_t @var{nbytes})
@deftypefnx {} {void}   gasnet_put_bulk (gasnet_node_t @var{node}, void *@var{dest}, void *@var{src}, size_t @var{nbytes})

Blocking get/put operations for bulk (unaligned) data. These function 
similarly to the aligned get/put operations above, except the data is 
permitted to be unaligned, and implementations are likely to optimize for 
larger sizes of nbytes.
@end deftypefn

@cindex memset
@FN gasnet_memset
@deftypefn {} {void}   gasnet_memset   (gasnet_node_t @var{node}, void *@var{dest}, int @var{val}, size_t @var{nbytes})

Blocking operation that has the same effect as if the @var{dest} node had executed the POSIX call
@code{memset(@var{dest}, @var{val}, @var{nbytes})}. 
As with puts, the destination memory must fall entirely within the memory area 
registered for remote access by the @var{dest} node (see @code{gasnet_attach}).
@end deftypefn

@c ------------------------------------------------------------------------------------
@node Non-blocking memory-to-memory transfers
@section Non-blocking memory-to-memory transfers
@cindex gets
@cindex puts

  The following functions provide non-blocking, split-phase memory access to 
shared data.

  All such non-blocking operations require an initiation (generally a put or get) and a 
subsequent synchronization on the completion of that operation before the 
result is guaranteed.

  There are two basic categories of non-blocking operations, 
defined by the synchronization mechanism used:
@table @emph
@cindex explicit handle non-blocking operations
@item "explicit handle" (nb) operations
These operations return a specific handle from the initiation that is used for synchronization.
The handle can be used to synchronize a specific subset of the nb operations in-flight
@cindex implicit handle non-blocking operations
@item "implicit handle" (nbi) operations 
These operations don't return a handle from the initiation - 
synchronization is accomplished by calling a synchronization 
routine that synchronizes all outstanding nbi operations.
@end table

@c ------------------------------------------------------------------------------------
@node Synchronization semantics of non-blocking data transfers
@subsection Synchronization semantics of non-blocking data transfers
@cindex Synchronization semantics

  Successful synchronization of a non-blocking get operation means the local 
result is ready to be examined, and will contain a value held by the source 
location at some time in the interval between the call to the initiation 
function and the successful completion of the synchronization (note this 
specifically allows implementations to delay the underlying read until the 
synchronization operation is called, provided they preserve the blocking 
semantics of the synchronization function).

  Successful synchronization of a put operation means the source data has 
been written to the destination location and get operations issued 
subsequently by any thread (or load instructions issued by the destination 
node) will receive the new value or a subsequently written value (assuming 
no other threads are writing the location)

  Note that the order in which non-blocking operations complete is 
intentionally unspecified - the system is free to coalesce and/or reorder 
non-blocking operations with respect to other blocking or non-blocking 
operations, or operations initiated from a separate thread - the only 
ordering constraints that must be satisfied are those explicitly enforced 
using the synchronization functions (i.e. the non-blocking operation is only 
guaranteed to occur somewhere in the interval between initiation and 
successful synchronization on that operation).

  Implementors should attempt to make the non-blocking initiation operations 
return as quickly as possible - however in some cases (e.g. when a large 
number of non-blocking operations have been issued or the network is 
otherwise busy) it may be necessary to block temporarily while waiting for 
the network to become available. In any case, all implementations must 
support an unlimited number of non-blocking operations in-progress - that 
is, the client is free to issue an unlimited number of non-blocking 
operations before issuing a sync operation, and the implementation must 
handle this correctly without deadlock or livelock. 

@c ------------------------------------------------------------------------------------
@node Non-blocking memory-to-memory transfers (explicit handle)
@subsection Non-blocking memory-to-memory transfers (explicit handle)

The explicit-handle non-blocking data transfer functions return a 
@code{gasnet_handle_t} value to represent the non-blocking operation in flight. 
@code{gasnet_handle_t} is an opaque type whose contents are implementation-defined, 
with one exception - every implementation must provide a value corresponding 
to an "invalid" handle (@code{GASNET_INVALID_HANDLE}) and furthermore this value 
must be the result of setting all the bytes in the @code{gasnet_handle_t} datatype 
to zero. Implementators are free to define the @code{gasnet_handle_t} type to be 
any reasonable and appropriate size, although they are recommended to use a 
type which fits within a single standard register on the target 
architecture. In any case, the datatype should be wide enough to express at least 
@iftex
@tex
$2^{16}-1$
@end tex
@end iftex
@ifnottex
2^16-1 
@end ifnottex
different handle values, to prevent limiting the number of 
non-blocking operations in progress due to the number of handles available.  It 
@strong{is} legal for clients to pass @code{gasnet_handle_t} values into function callees 
or back to function callers.

In the case of multithreaded clients (@code{GASNET_PAR} or @code{GASNET_PARSYNC}), 
@code{gasnet_handle_t} values are thread-specific. In other words, it is an error 
to obtain a handle value by initiating a non-blocking operation on one 
thread, and later pass that handle into a synchronization function from a 
different thread. 

Any explicit-handle, non-blocking operation may return @code{GASNET_INVALID_HANDLE} 
to indicate it was possible to complete the operation immediately without 
blocking (e.g. operations where the "remote" node is actually the local 
node)

It is always an error to discard the @code{gasnet_handle_t} value for an 
explicit-handle operation in-flight - i.e. to initiate an operation and never 
synchronize on its completion.

@FNH gasnet_get_nb, gasnet_put_nb
@FNI gasnet_get_nb
@FNI gasnet_put_nb
@deftypefn {} {gasnet_handle_t} gasnet_get_nb (void *@var{dest}, gasnet_node_t @var{node}, void *@var{src}, size_t @var{nbytes}) 
@deftypefnx {} {gasnet_handle_t} gasnet_put_nb (gasnet_node_t @var{node}, void *@var{dest}, void *@var{src}, size_t @var{nbytes}) 

Non-blocking get/put functions for aligned data. These functions operate 
similarly to their blocking counterparts, except they initiate a 
non-blocking operation and return immediately with a handle (@code{gasnet_handle_t}) 
which must later be used (by calling an explicit @code{gasnet_*_syncnb*()} function), to 
synchronize on completion of the non-blocking operation. The contents of the 
destination memory address are undefined until a synchronization completes 
successfully for the non-blocking operation. For the put version, the source 
memory may be safely overwritten once the initiation function returns.
@end deftypefn

@FNH gasnet_get_nb_bulk, gasnet_put_nb_bulk
@FNI gasnet_get_nb_bulk
@FNI gasnet_put_nb_bulk
@deftypefn {} {gasnet_handle_t} gasnet_get_nb_bulk (void *@var{dest}, gasnet_node_t @var{node}, void *@var{src}, @w{size_t @var{nbytes}})
@deftypefnx {} {gasnet_handle_t} gasnet_put_nb_bulk (gasnet_node_t @var{node}, void *@var{dest}, void *@var{src}, @w{size_t @var{nbytes}})

Non-blocking get/put functions for bulk (unaligned) data. For the put 
version, the source memory may @strong{not} be safely overwritten until a 
successful synchronization for the operation. If the contents of the source 
memory change while the operation is in progress the result will be 
implementation-specific. These otherwise behave identically to the non-bulk 
variants (but are likely to be optimized for large transfers).
@end deftypefn

@cindex memset
@FN gasnet_memset_nb
@deftypefn {} {gasnet_handle_t} gasnet_memset_nb (gasnet_node_t @var{node}, void *@var{dest}, int @var{val}, size_t @var{nbytes})

Non-blocking operation that has the same effect as if the @var{dest} node had executed the POSIX call
@code{memset(@var{dest}, @var{val}, @var{nbytes})}. 
As with puts, the destination memory must fall entirely within the memory area 
registered for remote access by the @var{dest} node (see @code{gasnet_attach}).

The synchronization behavior is identical to a non-blocking, explicit-handle put operation (the 
@code{gasnet_handle_t} return value must be synchronized using an explicit-handle 
synchronization operation).
@end deftypefn

@c ------------------------------------------------------------------------------------
@node Synchronization for explicit-handle non-blocking operations:
@subsection Synchronization for explicit-handle non-blocking operations:
@cindex synchronization 

GASNet supports two basic types of synchronization for non-blocking 
operations - trying (polling) and waiting (blocking). All explicit-handle 
synchronization functions take one or more @code{gasnet_handle_t} values as input 
and either return an indication of whether the operation has completed or 
block until it completes. 

@FNH gasnet_wait_syncnb, gasnet_try_syncnb
@FNI gasnet_wait_syncnb
@FNI gasnet_try_syncnb
@deftypefn {} {void} gasnet_wait_syncnb (gasnet_handle_t @var{handle})
@deftypefnx {} {int}  gasnet_try_syncnb (gasnet_handle_t @var{handle})

Synchronize on the completion of a single specified explicit-handle 
non-blocking operation that was initiated by the calling thread. 
@code{gasnet_wait_syncnb()} blocks until the specified operation has completed (or 
returns immediately if it has already completed). In any case, the handle 
value is "dead" after @code{gasnet_wait_syncnb()} returns and may not be used in 
future synchronization operations.
@code{gasnet_try_syncnb()} always returns immediately, with the value @code{GASNET_OK} if 
the operation is complete (at which point the handle value is "dead", and 
may not be used in future synchronization operations), or 
@code{GASNET_ERR_NOT_READY} if the operation is not yet complete and future 
synchronization is necessary to complete this operation.

It is legal to pass @code{GASNET_INVALID_HANDLE} as input to these functions - 
@code{gasnet_wait_sync(GASNET_INVALID_HANDLE)} returns immediately and 
@code{gasnet_try_sync(GASNET_INVALID_HANDLE)} returns @code{GASNET_OK}.

It is an error to pass a @code{gasnet_handle_t} value for an operation which has 
already been successfully synchronized using one of the explicit-handle 
synchronization functions.
@end deftypefn

@FNH gasnet_wait_syncnb_all, gasnet_try_syncnb_all
@FNI gasnet_wait_syncnb_all
@FNI gasnet_try_syncnb_all
@deftypefn {} {void} gasnet_wait_syncnb_all (gasnet_handle_t *@var{handles}, size_t @var{numhandles})
@deftypefnx {} {int}  gasnet_try_syncnb_all (gasnet_handle_t *@var{handles}, size_t @var{numhandles})

Synchronize on the completion of an array of non-blocking explicit-handle 
operations (all of which were initiated by this thread). @var{numhandles} 
specifies the number of handles in the provided array of handles. 
@code{gasnet_wait_syncnb_all()} blocks until all the specified operations have 
completed (or returns immediately if they have all already completed). 
@code{gasnet_try_syncnb_all} always returns immediately, with the value @code{GASNET_OK} 
if all the specified operations have completed, or @code{GASNET_ERR_NOT_READY} if 
one or more of the operations is not yet complete and future synchronization 
is necessary to complete some of the operations.

Both functions will modify the provided array to reflect completions - 
handles whose operations have completed are overwritten with the value 
@code{GASNET_INVALID_HANDLE}, and the client may test against this value when 
@code{gasnet_try_syncnb_all()} returns @code{GASNET_ERR_NOT_READY} to determine which 
operations are complete and which are still pending.

It is legal to pass the value @code{GASNET_INVALID_HANDLE} in some of the array 
entries, and both functions will ignore it so that it has no effect on 
behavior. For example, if all entries in the array are @code{GASNET_INVALID_HANDLE} 
(or @var{numhandles}==0), then @code{gasnet_try_sync_all_list()} will return @code{GASNET_OK}.
@end deftypefn

@FNH gasnet_wait_syncnb_some, gasnet_try_syncnb_some
@FNI gasnet_wait_syncnb_some
@FNI gasnet_try_syncnb_some
@deftypefn {} {void} gasnet_wait_syncnb_some (gasnet_handle_t *@var{handles}, size_t @var{numhandles})
@deftypefnx {} {int}  gasnet_try_syncnb_some (gasnet_handle_t *@var{handles}, size_t @var{numhandles})

These operate analogously to the @code{gasnet_*_syncnb_all} variants, except they only 
wait/test for at least one operation corresponding to a @emph{valid} handle in 
the provided list to be complete (the valid handles values are all those 
which are not @code{GASNET_INVALID_HANDLE}). Specifically, 
@code{gasnet_wait_syncnb_some()} will block until at least one of the valid handles 
in the list has completed, and indicate the operations that have completed 
by setting the corresponding handles to the value @code{GASNET_INVALID_HANDLE}. 
Similarly, @code{gasnet_try_syncnb_some} will check if at least one valid handle in 
the list has completed (setting those completed handles to 
@code{GASNET_INVALID_HANDLE}) and return @code{GASNET_OK} if it detected at least one 
completion or @code{GASNET_ERR_NOT_READY} otherwise.

Both functions ignore @code{GASNET_INVALID_HANDLE} values so those values have no 
effect on behavior. If the input array is empty or consists only of 
@code{GASNET_INVALID_HANDLE} values, @code{gasnet_wait_sync_some_list} will return 
immediately and @code{gasnet_try_sync_some_list} will return @code{GASNET_OK}.
@end deftypefn

@c ------------------------------------------------------------------------------------
@node Non-blocking memory-to-memory transfers (implicit handle)
@subsection Non-blocking memory-to-memory transfers (implicit handle)

@cindex memset
@cindex implicit-handle
@FNH gasnet_get_nbi, gasnet_put_nbi, gasnet_get_nbi_bulk, gasnet_put_nbi_bulk, gasnet_memset_nbi
@FNI gasnet_get_nbi
@FNI gasnet_put_nbi
@FNI gasnet_get_nbi_bulk
@FNI gasnet_put_nbi_bulk
@FNI gasnet_put_nbi_bulk
@FNI gasnet_memset_nbi
@deftypefn {} {void} gasnet_get_nbi      (void *@var{dest}, gasnet_node_t @var{node}, void *@var{src}, size_t @var{nbytes}) 
@deftypefnx {} {void} gasnet_put_nbi      (gasnet_node_t @var{node}, void *@var{dest}, void *@var{src}, size_t @var{nbytes}) 
@deftypefnx {} {void} gasnet_get_nbi_bulk (void *@var{dest}, gasnet_node_t @var{node}, void *@var{src}, size_t @var{nbytes})
@deftypefnx {} {void} gasnet_put_nbi_bulk (gasnet_node_t @var{node}, void *@var{dest}, void *@var{src}, size_t @var{nbytes})
@deftypefnx {} {void} gasnet_memset_nbi (gasnet_node_t @var{node}, void *@var{dest}, int @var{val}, size_t @var{nbytes})

Non-blocking get/put functions for aligned and unaligned (bulk) data. These 
functions operate similarly to their explicit-handle counterparts, except 
they do not return a handle and must be synchronized using the 
implicit-handle synchronization operations. The contents of the destination memory 
address are undefined until a synchronization completes successfully for the 
non-blocking operation. As with the explicit-handle variants, the source 
memory for the non-bulk put operation may be safely overwritten once the 
initiation function returns, but the bulk put version requires the source 
memory to remain unchanged until the operation has been successfully 
completed using a synchronization.

@code{gasnet_memset_nbi} behaves identically to @code{gasnet_memset_nb}, 
except that it is synchronized as if it were a non-blocking, implicit-handle put operation.

@end deftypefn

@c ------------------------------------------------------------------------------------
@node Synchronization for implicit-handle non-blocking operations:
@subsection Synchronization for implicit-handle non-blocking operations:
@cindex synchronization 

The following functions are used to synchronize implicit-handle non-blocking operations.

In the case of multithreaded clients, implicit-handle synchronization 
functions only synchronize the implicit-handle non-blocking operations 
initiated from the calling thread. Operations initiated by other threads 
sharing the GASNet interface proceed independently and are not synchronized. 
Implicit-handle synchronization functions will synchronize operations 
initiated within other function frames by the calling thread (but this 
cannot affect the correctness of correctly synchronized code).

@FNH gasnet_wait_syncnbi_gets, gasnet_wait_syncnbi_puts, gasnet_wait_syncnbi_all, gasnet_try_syncnbi_gets, gasnet_try_syncnbi_puts, gasnet_try_syncnbi_all
@FNI gasnet_wait_syncnbi_gets
@FNI gasnet_wait_syncnbi_puts
@FNI gasnet_wait_syncnbi_all
@FNI gasnet_try_syncnbi_gets
@FNI gasnet_try_syncnbi_puts
@FNI gasnet_try_syncnbi_all
@deftypefn {} {void} gasnet_wait_syncnbi_gets ()
@deftypefnx {} {void} gasnet_wait_syncnbi_puts ()
@deftypefnx {} {void} gasnet_wait_syncnbi_all ()
@deftypefnx {} {int}  gasnet_try_syncnbi_gets ()
@deftypefnx {} {int}  gasnet_try_syncnbi_puts ()
@deftypefnx {} {int}  gasnet_try_syncnbi_all ()

These functions implicitly specify a set of non-blocking operations on which 
to synchronize. They synchronize on a set of outstanding non-blocking 
implicit-handle operations initiated by this thread - either all such gets, 
all such puts, or all such puts and gets (where outstanding is defined as 
all those implicit-handle operations which have been initiated (outside an 
access region) but not yet completed through a successful implicit 
synchronization). The wait variants block until all operations in this 
implicit set have completed (indicating these operations have been 
successfully synchronized). The try variants test whether all operations in 
the implicit set have completed, and return @code{GASNET_OK} if so (which indicates 
these operations have been successfully synchronized) or 
@code{GASNET_ERR_NOT_READY} otherwise (in which case @emph{none} of these operations may 
be considered successfully synchronized). 

If there are no outstanding implicit-handle operations, these 
synchronization functions all return immediately (with @code{GASNET_OK} for the try 
variants).
@end deftypefn

@IMPNOTE{
@item Some implementations may choose to synchronize operations from other 
independent threads as well, but they must ensure progress for the calling 
thread in the presence of another thread which is continuously initiating 
implicit-handle non-blocking operations.
}

@c ------------------------------------------------------------------------------------
@node Implicit access region synchronization
@subsection Implicit access region synchronization
@cindex synchronization 

In some cases, it may be useful or desirable to initiate a number of 
non-blocking shared-memory operations (possibly without knowing how many at 
compile-time) and synchronize them at a later time using a single, fast 
synchronization. 
Simple implicit handle synchronization may not be appropriate for this 
situation if there are intervening implicit accesses which are not to be 
synchronized.
This situation could be handled using explicit-handle non-blocking 
operations and a list synchronization (e.g. @code{gasnet_wait_syncnb_all()}), but 
this may not be desirable because it requires managing an array of handles 
(which could have negative cache effects on performance, or could be 
expensive to allocate when the size is not known until runtime).
To handle these cases, we provide "implicit access region" synchronization, 
described below.

@FNH gasnet_begin_nbi_accessregion, gasnet_end_nbi_accessregion
@FNI gasnet_begin_nbi_accessregion
@FNI gasnet_end_nbi_accessregion
@deftypefn {} {void}            gasnet_begin_nbi_accessregion ();
@deftypefnx {} {gasnet_handle_t} gasnet_end_nbi_accessregion ();

@code{gasnet_begin_nbi_accessregion()} and @code{gasnet_end_nbi_accessregion()} are used 
to define an implicit access region (any code which dynamically executes 
between the begin and end calls is said to be "inside" the region)
The begin and end calls must be paired, and may not be nested recursively or 
the results are undefined.
It is erroneous to call any implicit-handle synchronization function within 
the access region.
All implicit-handle non-blocking operations initiated inside the region 
become "associated" with the abstract access region handle being 
constructed. @code{gasnet_end_nbi_accessregion()} returns an explicit handle which 
collectively represents all the associated implicit-handle operations (those 
initiated within the access region). 
This handle can then be passed to the regular explicit-handle 
synchronization functions, and will be successfully synchronized when @emph{all} of 
the associated non-blocking operations (both puts and gets) initiated in the 
access region have completed. 
The associated operations cease to be implicit-handle operations, and are 
@emph{not} synchronized by subsequent calls to the implicit-handle 
synchronization functions occurring after the access region (e.g. 
@code{gasnet_wait_syncnbi_all()}).
Explicit-handle operations initiated within the access region operate as 
usual and do @emph{not} become associated with the access region.
@end deftypefn

Sample code:
@lisp
  gasnet_begin_nbi_accessregion(); // begin the access region

  gasnet_put_nbi_shared(...); // becomes assoc. with access region
  while (...) @{
    gasnet_put_nbi_shared(...); // becomes assoc. with access region
  @}

  // unrelated explicit-handle operation not assoc. with access region
  h2 = gasnet_get_nb_shared(...); 
  gasnet_wait_syncnb(h2);

  // end the access region and get the handle
  handle = gasnet_end_nbi_accessregion(); 

  .... // other code, which may include unrelated implicit-handle 
       // operations+syncs, or other regions, etc

  // wait for all the operations assoc. with access region to complete
  gasnet_wait_syncnb(handle); 
@end lisp

@c ------------------------------------------------------------------------------------
@node Register-memory operations
@section Register-memory operations
@cindex gets
@cindex puts

Register-memory operations allow client code to avoid forcing communicated 
data to pass through the local memory system. Some interconnects may be able 
to take advantage of this capability and launch remote puts directly from 
registers or recieve remote gets directly into registers.

@c ------------------------------------------------------------------------------------
@node Value Put
@subsection Value Put

@FNH gasnet_put_val, gasnet_put_nb_val, gasnet_put_nbi_val
@FNI gasnet_put_val
@FNI gasnet_put_nb_val
@FNI gasnet_put_nbi_val
@deftypefn {} {void}            gasnet_put_val    (gasnet_node_t @var{node}, void *@var{dest},   @w{gasnet_register_value_t @var{value}, size_t @var{nbytes}});
@deftypefnx {} {gasnet_handle_t} gasnet_put_nb_val (gasnet_node_t @var{node}, void *@var{dest},  @w{gasnet_register_value_t @var{value}, size_t @var{nbytes}});
@deftypefnx {} {void}            gasnet_put_nbi_val (gasnet_node_t @var{node}, void *@var{dest}, @w{gasnet_register_value_t @var{value}, size_t @var{nbytes}});

Register-to-remote-memory put - these functions take the value to be put as 
input parameter to avoid forcing outgoing values to local memory in client 
code. 
Otherwise, the behavior is identical to the memory-to-memory versions of put above.
Requires: @code{nbytes > 0 && nbytes <= SIZEOF_GASNET_REGISTER_VALUE_T}.
The value written to the target address is a direct byte copy of the 
8*@var{nbytes} low-order bits of value, written with the endianness appropriate 
for an @var{nbytes} integral value on the current architecture.
The non-blocking forms of value put must be synchronized using the explicit 
or implicit synchronization functions defined above, as appropriate
@end deftypefn

@c ------------------------------------------------------------------------------------
@node Blocking Value Get
@subsection Blocking Value Get

@FN gasnet_get_val
@deftypefn {} {gasnet_register_value_t} gasnet_get_val (gasnet_node_t @var{node}, void *@var{src}, size_t @var{nbytes});

This function returns the fetched value to avoid 
forcing incoming values through local memory (on architectures 
which pass the return value in a register). 
Otherwise, the behavior is identical to the memory-to-memory blocking get.
Requires: @code{nbytes > 0 && nbytes <= SIZEOF_GASNET_REGISTER_VALUE_T}.
The value returned is the one obtained by reading the @var{nbytes} bytes starting 
at the source address with the endianness appropriate for an @var{nbytes} integral 
value on the current architecture and setting the high-order bits (if any) 
to zero (i.e. no sign-extension)
@end deftypefn

@c ------------------------------------------------------------------------------------
@node Non-Blocking Value Get (explicit-handle)
@subsection Non-Blocking Value Get (explicit-handle)

This operates similarly to the blocking form of value get, but is split-phase.
Non-blocking value gets are synchronized independently of all other 
operations in GASNet.

@findex gasnet_valget_handle_t
@code{typedef ??? gasnet_valget_handle_t;}

@FNH gasnet_get_nb_val, gasnet_wait_syncnb_valget
@FNI gasnet_get_nb_val
@FNI gasnet_wait_syncnb_valget
@deftypefn {} {gasnet_valget_handle_t} gasnet_get_nb_val (gasnet_node_t @var{node}, void *@var{src}, size_t @var{nbytes});
@deftypefnx {} {gasnet_register_value_t} gasnet_wait_syncnb_valget (gasnet_valget_handle_t @var{handle});

@code{gasnet_get_nb_val} initiates a non-blocking value get and returns an explicit 
handle which @strong{must} be synchronized using @code{gasnet_wait_syncnb_valget()}
@code{gasnet_wait_syncnb_valget()} synchronizes an outstanding @code{get_nb_val} operation 
and returns the retrieved value as described for the blocking version.
Note that @code{gasnet_valget_handle_t} and @code{gasnet_handle_t} are completely 
different datatypes and may not be intermixed (i.e. @code{gasnet_valget_handle_t}'s 
cannot be used with other explicit synchronization functions, and 
@code{gasnet_handle_t}'s cannot be passed to @code{gasnet_wait_syncnb_valget()}.
The @code{gasnet_valget_handle_t} type is completely opaque (with no special 
"invalid" value), although implementors are recommended to make 
@code{sizeof(gasnet_valget_handle_t) <= sizeof(gasnet_register_value_t)} to 
facilitate register reuse.
There is no try variant of value get synchronization, and no implicit-handle variant.
@end deftypefn

@c ------------------------------------------------------------------------------------
@node Barriers
@section Barriers
@cindex barrier

The following functions can be used to execute a parallel split-phase 
barrier with the given barrier identifier across all nodes in the job. 
Note that the barrier wait/notify functions should only be called once (i.e. 
by one representative thread) on each node per barrier phase.
The client must synchronize its own accesses to the barrier functions and 
ensure that only one thread is ever inside a GASNet barrier function at a 
time (esp. @code{gasnet_barrier_try()}).

@findex GASNET_BARRIERFLAG_ANONYMOUS
@findex GASNET_BARRIERFLAG_MISMATCH
@lisp
#define GASNET_BARRIERFLAG_ANONYMOUS ???
#define GASNET_BARRIERFLAG_MISMATCH ???
@end lisp

@FN gasnet_barrier_notify
@deftypefn {} {void} gasnet_barrier_notify (int @var{id}, int @var{flags})

Execute the notification for a split-phase barrier, with a barrier value @var{id}.
This is a non-blocking operation that completes immediately after noting the 
barrier value.
No synchronization is performed on outstanding non-blocking memory 
operations. 

Generates a fatal error if this is the second call to 
@code{gasnet_barrier_notify()} on this node since the last call to 
@code{gasnet_barrier_wait()} or the beginning of the program.

If @var{flags} == 0 then this is a "named" barrier notify that carries the given 
@var{id} value.
If @var{flags} == @code{GASNET_BARRIERFLAG_ANONYMOUS}, then @var{id} is ignored and the 
barrier is anonymous - it has no specific value. 
If @var{flags} == @code{GASNET_BARRIERFLAG_MISMATCH}, then the subsequent 
@code{gasnet_barrier_wait()} call on every node will return 
@code{GASNET_ERR_BARRIER_MISMATCH} (i.e. allows the client to force a global 
mismatch error when a mismatch was detected locally).
@end deftypefn

@FN gasnet_barrier_wait
@deftypefn {} {int} gasnet_barrier_wait (int @var{id}, int @var{flags})

Execute the wait for a split-phase barrier, with a barrier value.
This is a blocking operation that returns only after all remote nodes have 
called @code{gasnet_barrier_notify()}.
No synchronization is performed on outstanding non-blocking memory 
operations .

Generates a fatal error if there were no preceding calls to 
@code{gasnet_barrier_notify()} on this node, or if this is the second call to 
@code{gasnet_barrier_wait()} (or successful call to @code{gasnet_barrier_try()}) since the 
last call to @code{gasnet_barrier_notify()} on this node.
On a @code{GASNET_PAR} or @code{GASNET_PARSYNC} configuration, the thread calling 
@code{gasnet_barrier_notify()} is permitted to differ from the thread which calls 
the paired @code{gasnet_barrier_wait()}, but the ordering between the calls must 
still be maintained.

Returns @code{GASNET_ERR_BARRIER_MISMATCH} if @var{flags} is not equal to the @var{flags} value 
passed to the preceding @code{gasnet_barrier_notify()} call made by this node.
Returns @code{GASNET_ERR_BARRIER_MISMATCH} if the @var{flags} value passed to 
@code{gasnet_barrier_notify()} on this or any other node was 
@code{GASNET_BARRIERFLAG_MISMATCH}.
Returns @code{GASNET_ERR_BARRIER_MISMATCH} if @var{flags}==0 and the supplied @var{id} value 
doesn't match the @var{id} value provided in the preceding @code{gasnet_barrier_notify()} 
call made by this node.
Returns @code{GASNET_ERR_BARRIER_MISMATCH} if any two nodes passed non-anonymous 
barrier values which didn't match during the @code{gasnet_barrier_notify()} calls 
which began this barrier phase.
Otherwise, returns @code{GASNET_OK} to indicate that all nodes have called a 
matching @code{gasnet_barrier_notify()} and the barrier phase is complete.
@end deftypefn

@FN gasnet_barrier_try
@deftypefn {} {int} gasnet_barrier_try (int @var{id}, int @var{flags})

@code{gasnet_barrier_try()} functions similarly to @code{gasnet_wait()}, except that it 
always returns immediately. 
If the barrier has been notified by all nodes, the call behaves as a call to 
@code{gasnet_barrier_wait()} with the same barrier @var{id} and @var{flags}, and returns 
@code{GASNET_OK} (or @code{GASNET_ERR_BARRIER_MISMATCH} in the case a mismatch is 
detected).
If the barrier has not yet been notified by some node, the call is a no-op 
and returns the value @code{GASNET_ERR_NOT_READY}.

Generates a fatal error if there were no preceding calls to 
@code{gasnet_barrier_notify()} on this node, or if this is the second call to 
@code{gasnet_barrier_wait()} (or successful call to @code{gasnet_barrier_try()}) since the 
last call to @code{gasnet_barrier_notify()} on this node.
@end deftypefn

@c ------------------------------------------------------------------------------------
@node Thread-identification optimization:
@section Thread-identification optimization:

When compiled in the @code{GASNET_PAR} or @code{GASNET_PARSYNC} configurations, GASNet is 
capable of handling multiple client threads. It is likely that GASNet 
implementations will need to distinguish these threads, specifically they 
may need to store some metadata associated with each client thread. 
Unfortunately, the overhead of discovering the identity of a particular 
client thread making a GASNet call (hereafter termed "thread discovery") can 
have a non-trivial overhead on some threading systems (e.g. the cost of 
calling @code{pthread_self()} or @code{pthread_getspecific()}). Many of the simpler GASNet 
functions could have their performance dominated by this cost if they need 
to perform thread discovery on every call.

The following macros provide a way for the client to amortize the cost of 
thread discovery over many GASNet calls made by the same thread. This is an 
optimization which is @emph{totally} optional - clients need not make any of the 
calls below to have a working system, although GASNet performance is likely 
to suffer without it in a @code{GASNET_PAR} or @code{GASNET_PARSYNC} configuration.

@code{typedef void *gasnet_threadinfo_t;}

@code{gasnet_threadinfo_t} is an opaque pointer representing the internal GASNet 
metadata associated with a particular client thread.
 
@FN GASNET_GET_THREADINFO
@code{#define GASNET_GET_THREADINFO() ???}

Returns a value of type @code{gasnet_threadinfo_t} which represents the GASNet 
internal metadata associated with the current client thread. This 
@code{gasnet_threadinfo_t} value can be passed into or out of functions and may be 
posted for GASNet's use with @code{GASNET_POST_THREADINFO()}. May be called from 
anywhere in the client program, at any time after GASNet initialization. It 
is erroneous to hand-off this @code{gasnet_threadinfo_t} value to a different 
client thread.

@FN GASNET_POST_THREADINFO
@code{#define GASNET_POST_THREADINFO(info) ???}

This macro may @emph{optionally} be placed at the top of functions which make 
calls to GASNet. It has no runtime semantics, but it may provide a 
performance boost on some implementations (especially in functions which 
make multiple calls to the extended API - e.g. it provides the 
implementation with a place for minimal per-function initialization or 
temporary storage that may be helpful in amortizing implementation-specific 
overheads). 
When used, it must appear only at the very beginning of a function or block 
(before any declarations or calls to the API in that function).  It may not 
appear as a global declaration. The info argument must be a 
@code{gasnet_threadinfo_t} value acquired from a previous call to 
@code{GASNET_GET_THREADINFO()} on this thread.

@FN GASNET_BEGIN_FUNCTION
@code{#define GASNET_BEGIN_FUNCTION()   GASNET_POST_THREADINFO(GASNET_GET_THREADINFO())}

A convenience macro that may be placed at the top of functions which 
repeatedly make GASNet calls, to amortize the overhead of thread discovery 
on some implementations.


@c ------------------------------------------------------------------------------------
@HR
@node Appendix
@appendix Notes

@menu
* Open Issues::
* Collective Operations::  
* Differences from AM2::  
* Discarded Design Ideas::
@end menu

@c ------------------------------------------------------------------------------------
@node Open Issues
@appendixsec Open Issues in the GASNet Specification
@itemize @bullet
@item
Need a user manual for gasnetrun (i.e. the user interface provided by 
the core's spawning system)
@item
Add support for strided & scatter/gather accesses (waiting to see UPC 
1.2 spec)
@item
Add collective ops - reductions, scans, etc. (waiting to see UPC 1.2 
spec)
@end itemize

@c ------------------------------------------------------------------------------------
@node Collective Operations
@appendixsec Collective Operations

@appendixsubsec Broadcast (not yet supported)

@deftypefn {} {void} gasnet_all_broadcast_T (void *@var{data}, size_t @var{nbytes}, gasnet_node_t @var{source})

@itemize @bullet
@item should this be a collective operation?
@item should it be blocking or split phase?
@item where should it place the result? return it? specified by each proc? 
specified by broadcaster for each/all?
@end itemize
@end deftypefn

@c ------------------------------------------------------------------------------------
@node Differences from AM2
@appendixsec Core API Active Messaging Functions - differences from Active Messages 2.0

The GASNet core API was originally based on Active Messages 2.0 (as 
described in @cite{A. Mainwaring and D. Culler in "Active Message Applications 
Programming Interface and Communication Subsystem Organization"}), however 
we've removed some of the generality which is not required (and can lead to 
performance degradation and more implementation effort), and stripped it 
down to the bare essentials required for active messages in a purely SPMD 
environment. The final spec more closely resembles the @cite{"Generic Active 
Message Interface Specification v.1.1", by D.Culler et al.}, however 
we describe the differences from AM2.0 for readers familiar with that 
specification (and because we envision a number of the GASNet core 
implementations being simply a thin wrapper over the existing AM2.0 
implementations on a number of platforms).

Here are a summary of the changes (informal style.. this is not really part 
of the spec):

@itemize @bullet
@item
the functions are renamed to match the GASNet conventions

@item
there are no bundles and only one (implicit) endpoint. This necessitates 
the following changes:
@itemize @bullet
@item
All AM2 functions which took an endpoint or bundle argument have that 
argument removed
@item
The following functions no longer exist: @code{AM_Init}, @code{AM_Terminate}, 
@code{AM_AllocateBundle}, @code{AM_AllocateEndpoint}, @code{AM_FreeEndpoint}, @code{AM_FreeBundle}, 
@code{AM_MoveEndpoint}, @code{AM_GetXferM}, @code{AM_GetDestEndpoint}
@end itemize

@item
all handler registration is performed during @code{gasnet_attach()}, and the 
maximum number of handlers is fixed at 256 (including handler 0, the error 
handler)
@itemize @bullet
@item
The following functions no longer exist: @code{AM_SetHandler} and 
@code{AM_SetHandlerAny}, @code{AM_GetNumHandlers}, @code{AM_SetNumberHandlers}, @code{AM_MaxNumHandlers}
@end itemize

@item
Segment registration is handled by @code{gasnet_attach()} (using a @code{uintptr_t} to 
allow entire VA space)
@itemize @bullet
@item
The following functions no longer exist: @code{AM_SetSeg} and @code{AM_MaxSegLength} 
(still have @code{AM_GetSeg})
@item
implementations must support an endpoint segment length that spans the 
entire virtual address space, though the performance may change for larger 
segment sizes (if @code{gasnet_attach} requests a size larger than what underlying 
@code{AM_SetSeg} can provide, then we turn off large AM Xfers and emulate 
gasnet_Xfer using medium messages)
@item 
the @code{dest_offset} argument to the Xfer functions is changed to a @code{void *} 
address
@end itemize

@item
there are no tags or endpoint names visible to the user - such details are 
all handled internally by the job startup mechanism, which sets up a 
SPMD-style mapping table (all the nodes, including the current node, in ascending 
order by rank).
@itemize @bullet
@item
Therefore, the following functions no longer exist: @code{AM_Map}, @code{AM_MapAny}, 
@code{AM_Unmap}, @code{AM_SetTag}, @code{AM_GetTag}, @code{AM_GetTranslationName}, @code{AM_GetTranslationTag}, 
@code{AM_GetTranslationInUse}, @code{AM_MaxNumTranslations}, @code{AM_GetNumTranslations}, 
@code{AM_SetNumTranslations}, @code{AM_GetMsgTag}
@item
the @code{en_t *} argument to @code{AM_GetSourceEndpoint} is now an @code{gasnet_node_t *} 
and returns the node rank of the sender (the now-opaque token could be 
implemented as the integer node index itself, although we allow 
implementations to still use it as a ptr to metadata if required)
@end itemize

@item
@code{AM_RequestXferAsyncM} has more useful semantics (may block)

@item
@code{AM_SetExpectedResources} no longer exists

@item
all implementations must support the @code{AM_PAR} (multi-threaded) access mode 
(@code{GASNET_PAR} configuration)

@item
we handle 64-bit implementations - require small size to be 16 32-bit args 
(ensure 8 @code{(void*)}'s can be sent) 

cons: handler code needs to be rewritten for 64-bit platforms to perform 
packing/unpacking
  
@item
Blocking polling operation is simplified in the following ways:
@itemize @bullet
@item
@code{AM_GetEventMask} and @code{AM_SetEventMask} no longer exist
@item
@code{AM_WaitSema} is replaced with @code{GASNET_BLOCKUNTIL()}
@end itemize

@item
Maybe deprecate @code{ReplyXfer} in favor of @code{GetXfer} 
@itemize @bullet
@item
some implementations have trouble with large @code{ReplyXfer}'s (with software 
flow control & reliability)
@item
better yet, just separate @code{AM_MaxLong} into @code{AM_MaxLongRequest}, and 
@code{AM_MaxLongReply}
@item
AM2.0 @code{GetXfer} doesn't add any expressiveness - really want a way to get 
from remote segment into arbitrary local memory address
@end itemize

@item
All Xfer functions specify the destination using a virtual memory address 
(which must fall within the registered segment) rather than a segment 
offset.

@item
request handlers are permitted to omit a reply call if no reply handler is 
needed (and some implementations may optimize this case)

@end itemize

@c ------------------------------------------------------------------------------------
@node Discarded Design Ideas
@appendixsec Discarded Design Ideas (not part of spec)

@itemize @bullet
@item
maybe all remote accesses and large xfers should be in terms of segment 
offsets rather than virtual addresses 

pros: helps upcr optimize shared ptr rep (faster addr calc, less bits 
reqd, slower deref), handle unaligned segments automatically, 
bounds-checking could be slightly faster

cons: short-circuiting local accesses includes one extra indirection, 
hardware supported RDMA probably can't handle an offset (need to translate 
to virtual address on requester)

@item
alt approach for AM handlers on 64-bit: make the handler args scale with 
pointer size (64-bit ints)

    cons: LP64 platforms (like Itanium) have 32-bit ints, but 64-bit ptrs
send twice as many bits in each message just because of pointer width, even if not needed

@end itemize


@c ------------------------------------------------------------------------------------

@node Concept Index
@unnumbered Concept Index

@printindex cp

@node Function Macro and Type Index
@unnumbered Function, Macro and Type Index

@printindex fn

@ifhtml
@c make html generator happy
@contents
@end ifhtml

@bye
