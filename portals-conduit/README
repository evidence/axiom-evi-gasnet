GASNet Portals-conduit documentation
Michael Welcome <mlwelcome@lbl.gov>
$Revision: 1.8 $

User Information:
-----------------
The GASNet Portals conduit is being developed exclusively for the 
Cray XT3/XT4 and follow-on Portals based systems.  The design and implementation is 
based on the Portals 3.3 Message Passing Interface (Revision 1.0) developed at 
Sandia National Laboratory and the University of New Mexico.  These should
be only a few modifications required to port this implementation to non-Cray
Portals systems.

This implementation runs under both the Cray Catamount and Compute Node Linux (CNL)
operating systems.  Also, note that earlier implementations of this conduit
were hybrid implementations, using Portals directly for Put and Get operations
and the MPI-conduit for the active message layer.  This version of the conduit
is implemented entirely over Portals and has no MPI dependencies.

This implementation will only work under the GASNET_SEGMENT_FAST environment, although
modification to GASNET_SEGMENT_EVERYTHING are possible using the GASNet FireHose
algorithm.
In addition, this implementation is restricted as follows:
  Under Catamount:  GASNET_SEQ  (no threading environment under Catamount)
  Under CNL:        GASNET_SEQ and GASNET_PAR.  

Note:  One could use GASNET_PARSYNC by simply defining GASNET_PAR but there 
       are probably several efficiencies to be gained by combing through the 
       uses of locks to see which would be required in this environment and
       which are not needed.


Some notes on building GASNet for the Cray XT3/XT4
--------------------------------------------------

* Since the XT3/XT4 requires using a cross-compiler, there is a special cross
  configuration script located in 
      $GASNET_SRC_DIR/other/contrib/cross-configure-crayxt-catamount
  for a Catamount system OR
      $GASNET_SRC_DIR/other/contrib/cross-configure-crayxt-linux
  for CNL.

   Instructions for building gasnet are:
   cd $GASNET_SRC_DIR
   cp other/contrib/cross-configure-crayxt-<OS> .
   ./Bootstrap
   vi ./cross-configure-crayxt-<OS>
      to modify any of the configure-time options, such as turning on DEBUG or TRACE mode.
   ./cross-configure-crayxt-<OS>
   make

* Special notes on configuring for GASNET-PAR under CNL
  You must be sure to use the correct version of the pthreads, one that works
  with Portals.  At the time of this writing, 09/01/2007, the only Portals-compatible
  pthreads library available on CNL is NPTL, which is located
  in /usr/lib64/nptl.  The header files are in /usr/include/nptl.
  Unfortunately, the pthread.h header file in /usr/include/nptl is buggy and needs
  to be modified.  The easiest thing to do is copy the /usr/include/nptl directory
  to a local location, say $HOME/nptl.  Modify the pthread.h file as follows:

  Change:
	extern int __sigsetjmp (struct __jmp_buf_tag __env[1], int __savemask) __THROW;
  To:
	extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) __THROW;
  Change:
  #define PTHREAD_MUTEX_INITIALIZER {}
  #define PTHREAD_COND_INITIALIZER {}
  To:
  #define PTHREAD_MUTEX_INITIALIZER { { 0 } }
  #define PTHREAD_COND_INITIALIZER { { 0 } }

  Assuming no significant changes to pthread.h, this patching can be done automatically
  (and non-destructively) during configure by using the configure argument: 
    --with-pthreads-patch=other/contrib/crayxt-nptl-pthread-patch

  Finally, the following to EXTRA_CONFIGURE_ARGS in cross-configure-crayxt-linux ensure
  the use of NPTL libraries and headers:
    --with-pthreads-include=/usr/include/nptl --with-pthreads-lib=/usr/lib64/nptl 
  these settings are on by default in cross-configure-crayxt-linux.

Recognized environment variables:
---------------------------------
GASNET_PORTAL_CREDIT_STATS=1 
  will write credit stats to a file.  This allows a developer to get a sense of
  how the flow-control credits are distributed.

GASNET_PORTAL_SB_CHUNKS=N
  Specifies to allocate this number of memory chunks to the Request Send Buffer
  memory descriptor.  Each active message request must allocate a chunk for its
  use.  The chunk is held until the corresponding AM Reply arrives.
  These chunks are also used as bounce buffers for small Put and Get operations.

GASNET_PORTAL_RPL_CHUNKS=N
  Specifies to allocate this number of memory chunks to the Request Reply Buffer
  memory descriptor.  Each active message reply must allocate a chunk for its use.
  The chunk is freed when the AM Reply is known to have been sent off-node.

GASNET_PORTAL_NUM_TMPMD=N
  Specifies the number of temporary memory descriptors that can be allocated
  at any time.  The default value is 1024.
  Temporary MDs are allocated when a Put or Get operation is initiated, the
  message is larger than what would fit into a Request chunk (bounce buffer)
  and the memory for the source of the Put or dest of the Get is not already
  pinned (eg. if it were in the local segment).

GASNET_PORTAL_MSG_LIMIT=N
  This value limits the total number of messages in-flight from this node.
  Given that the Cray seastar has 256 available slots in the DMA engine, any more
  in-flight messages requires a more expensive reliability algorithm to be
  used at the low levels.  This value only limits the number of INITIATED
  messages, there is no control over the number of incoming messages, which
  also consume DMA slots.  Earlier tests showed that performance would drop
  if this value got much larger than about 300.  The default value is 250.

GASNET_PORTAL_PACKED_LONG=N
  If N=0, this turns off the ability to pack short-payload AM Long messages
  into a Request Send Buffer chunk.  A normal AM Long request or reply will
  send two messages, a header and a data put.  For small AM Long messages,
  using PACKED longs has better performance.
  The default value is N=1, allowing PACKED AM Longs.

GASNET_PORTAL_EPOCH_DURATION=

GASNET_PORTAL_FLOW_CONTROL=N
  if N=1, then active message flow control is enabled.  This is the default.
  N=0 disables flow control, but the application may fail if a node receives too
  many AM requests such that its receive buffer overflows.

GASNET_PORTAL_DYNAMIC_CREDITS=N
  If N=1, then dynamic credit management is enabled.  This is the default.
  With dynamic credit management, a node dynamically distributes its credits to
  the nodes it has been communicating with recently.  
  N=0 disables this feature.

GASNET_PORTAL_MAX_CRED_PER_NODE=N
  This value limits the total number of credits that can be allocated to a 
  remote node.
  The default value is 400.

GASNET_PORTAL_SAFE_LIMIT=N
  This value defines the maximum number of events that are allowed to be processed
  on the SAVE event queue, per polling call.  
  The default value is 12.

GASNET_PORTAL_AM_LIMIT=N
  This value defines the maximum number of events that are allowed to be processed
  on the AM event queue, per polling call.  
  The default value is 8.

GASNET_PORTAL_SYS_LIMIT=N
  This value defines the maximum number of events that are allowed to be processed
  on the AM event queue, per polling call.  
  The default value is 0, meaning there is no limit.  That is, all events are 
  processed per polling call.

GASNET_PORTAL_CRED_PER_NODE=
GASNET_PORTAL_BANKED_CREDITS
GASNET_PORTAL_AMRECV_SPACE

GASNET_PORTAL_ACCEL=N      /* if built with -DGASNETC_USE_SANDIA_ACCEL */
  This value can only be used on a Sandia based Catamount system with
  accelerated portals.  In this environment, the majority of the portals
  processing is done on the seastar chip, rather than on the opteron.
  If N=1, (and GASNet is built with the -DGASNETC_USE_SANDIA_ACCEL flag)
  then accelerated mode is enabled.
  The default is N=0.

* All the standard GASNet environment variables (see top-level README)

* The GASNET_EXITTIMEOUT family of environment variables (see top-level README)


Optional compile-time settings:
------------------------------

* All the compile-time settings from extended-ref (see the extended-ref README)

Known problems:
---------------

* See the Berkeley UPC Bugzilla server for details on known bugs.

*  On CNL, if we try to pin more memory than the OS will allow, the job is killed.
   Therefore there is really no way (that we know of) to determine the maximum
   pinnable memory (and therefore maximal GASNET_SEGMENT_FAST segment size)
   under CNL without dire consequences - furthermore the maximal value appears
   to be site-specific. Currently portals-conduit leaves this quantity
   unlimited (subject only to GASNET_MAX_SEGSIZE, which determines the maximal
   mmap) and jobs requesting too large a GASNet segment will be killed by the
   kernel with an error message like:

     [NID 18]Apid 49229: initiated application termination
     Application 49229 exit signals: Killed

   Programs encountering this error are recommended to reduce their GASNet
   segment size demands, either at the GASNet client level (eg
   UPC_SHARED_HEAP_SIZE), or by setting environment variable GASNET_MAX_SEGSIZE
   to a smaller value to impose a segment limit.  The default value for
   GASNET_MAX_SEGSIZE can be established at configure time using:
   --with-segment-mmap-max=XGB


==============================================================================

A Brief Overview of Portals:
---------------------------
At this point, the implementation is relatively straight-forward.   GASNet Put
and Get operations are implemented in terms of Portals PtlPutRegion and PtlGetRegion
operations.  

Portals Put and Get operations are RDMA operations between a local and remote "Memory
Descriptor".  A Memory Descriptor represents a pinned region of memory that is endowed 
with various properties, such as what type of events will be generated on the MD, which
operations are permitted to be performed on the MD, and how the memory is managed ("Locally"
or "Remotely").  In addition, Portals MDs can be Free Floating, or on an ordered list attached
to a Portals Table Entry.  MDs that are attached to a Portals Table Entry are accessable 
to remote agents as the target of Put or source of Get RDMA operations.  Such MDs have
a set of 64 bits called "Match-Bits".  These MDs may also have a mask called the "Ignore-bits",
which will be discussed below.

All Portals operations are non-blocking and do not return a handle.  Depending on 
how the associated memory descriptors are configured, Portals Put and Get operations
generate events on the source and destination memory descriptors.  When a Portals
Put operation is issued, the caller supplies the local source memory descriptor, but the 
remote destination memory descriptor is determined by specifying a portals table entry
index and a set of 64 match-bits.  When the packet header of the message arrives at the
destination node, the memory descriptors attached to that portals table entry are examined
in order.  The first MD that matches the Match-bits of the Put operation (after being masked
by the MD's Ignore-bits) is selected as the target MD.
A similar procedure happens for Get operations.  The caller of the Get operation specifies
the memory descriptor of the data destination, but the data source is specified
by a portals table entry and set of match-bits.

Depending on how an MD is configured, events will be generated based on underlying 
actions associated with Portals Put and Get operations.  The events used in this
GASNet implementation are:
PTL_EVENT_SEND_END   - a locally initiated Put operation has been sent
PTL_EVENT_ACK        - a locally initiated Put operation has reached its remote destination MD
PTL_EVENT_PUT_END    - a remotely initiated Put operation has completed on a local MD
PTL_EVENT_GET_END    - a remotely initiated Get operation has completed on a local MD
PTL_EVENT_REPLY_END  - a locally initiated Get operation has completed on a local MD

Memory Descriptors uses in the GASNet Implementation
----------------------------------------------------
RAR
RARSRC
RARAM
ReqSB
RplSB
ReqRB
CB
TMPMD

Event Queues used in the GASNet Implementation
----------------------------------------------
SAFE_EQ
AM_EQ
SYS_EQ
TMP_EQ

The Implemention of GASNet Put and Get Operations
-------------------------------------------------

At startup the local shared memory segment (Remote Access Region or RAR) is allocated and
covered by two Portals Memory Descriptors: RAR_MD and RARAM_MD.
In addition, a bounce buffer region is allocated and covered with the ReqSB_MD 
memory descriptor.
A single Event Queue (EQ) is allocated with enough events to handle the maximum number
of Put/Get operations allowed at any time (see environment variable GASNET_PORTAL_PUTGET_LIMIT).

RAR_MD does not have a Portals event queue associated with it and therefore no events will be
generated when operations are performed on it.  It is linked on the Portals Table Entry at 
index RAR_PTE, with MATCH_BITS=0x00.  It is used as the target of GASNet Put and source of 
GASNet Get operations.

RARAM_MD is associated with the event queue (EQ) and is linked on the Portals
table entry at index RAR_PTE with MATCH_BITS=0x01.  It is uses as 
the source of a GASNet Put operation (when the source happens to lie within the
local RAR).  Similarly, it is used as the destination of a GASNet Get operation
when the destination lies in the local RAR.

Both RAR_MD and RARAM_MD are configured to ignore all but the lowest 4 bits of a
set of MATCH_BITS.

ReqSB_MD is associated with EQ.  It is a free-floating MD and therefore cannot be used
as the target of a remote Put or Get operation, only as the source of a Put or destination
of a locally initiated Get operation.  Further, this memory region is managed
by a simple "Chunk" allocator.  Currently, it allocates fixed-size, 1KB chunks.

Each GASNet Put or Get operation is associated with a GASNet handle, a polymorphic
typed object that records the state of the operation.  The objects can be referenced
by either a standard (64 bit) pointer, or a compact 24-bit representation that can
be converted to a pointer to the object.  

Consider the implementation of a non-blocking GASNet Put operation:

gasnet_handle_t gasnet_put_nb_bulk(void *dest, gasnet_node_t node, void *src, size_t nbytes);

* We know the destination node and virtual memory address of where the data is to be put.
  This region must lie within the RAR of the remote node.  We know the starting address of
  this RAR since this information was exchanged at job startup.  We know the RAR is 
  covered by the RAR_MD memory descriptor with MATCH_BITS=0x00 and we can compute the
  the (remote) offset from the start of this MD.

* There are several cases for determining the MD of the source memory region:
  (1) It lives within the local RAR.  If so, use the local RAR_MD as the source
      MD and compute the (local) offset as src - RAR_MD_start_address.
  (2) It does not live within the local RAR, but nbytes <= 1KB.  Allocate a chunk
      from ReqSB_MD and copy the data into this bounce buffer.  Compute the (local)
      offset of this chunk from the start of ReqSB_MD.
  (3) It does not live in the local RAR and is too big to be copied though a bounce
      buffer.  Allocate a temporary memory descriptor (TEMP_MD) to cover the 
      region to be sent.  Se the local_offset = 0.

* Allocate a gasnet_handle_t object and encode its 24-bit representation into a portion of
  the 64-bit MATCH_BITS that will be ignored by the remote memory descriptors (the upper 60 bits).
  The handle is marked "IN_FLIGHT".

* Issue the PtlPutRegion operation from the selected local MD and local_offset to the
  remote node, specifying the RAR_PTE portals table entry and MATCH_BITS as specified 
  above.  Request that an ACK event be delivered when the data has been written to the
  remote memory.

* return the gasnet_handle_t object to the client.

At some point later in time, the data will be sent to the remote node, generating a 
PTL_EVENT_SEND_END event on the local source MD.  In addition, when the data has been delivered to
the target memory, an PTL_EVENT_ACK event will delivered to the source MD.
At some point in time, the client or runtime layer will poll the network, processing outstanding
events.  For this Put operation, the events will cause the following action:

** The SEND_END event will be ignored by all memory descriptors for this operation.
** The ACK event will cause the following actions:
   - the 24 bit representation of the gasnet_handle_t object will be extracted from
     the MATCH_BITS in the event structure.  The 64-bit pointer to the object will be
     generate from the 24-bit representation.  The operation will be marked "DONE".
   - If the event occurred on the local RAR (case (1) above), no action is taken.
     If the event occurred on the ReqSB_MD (case (2)), this was a copy through a bounce
     buffer and the chunk is freed for re-use.
     If the event occurred on a TEMP_MD, the memory descriptor is "unlinked" (unpinned).

Finally, the next time the client or the runtime layer calls gasnet_wait_syncnb() or
gasnet_try_syncnb() with this handle, the handle is freed and the operation is complete.

GASNet Get operations are handled in a similar manner.  
All blocking operation poll the network until the desired operation is complete.

The Implemention of GASNet Active Messages
------------------------------------------

Credit Management for GASNet Active Messages
--------------------------------------------







